#!/usr/bin/python
# Copyright 2009 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Id$

import sys
# This block ensures that ^C interrupts are handled quietly.
try:
	import signal

	def exithandler(signum,frame):
		signal.signal(signal.SIGINT, signal.SIG_IGN)
		signal.signal(signal.SIGTERM, signal.SIG_IGN)
		sys.exit(1)

	signal.signal(signal.SIGINT, exithandler)
	signal.signal(signal.SIGTERM, exithandler)

except KeyboardInterrupt:
	sys.exit(1)

import logging
import optparse
import os
import portage
import _emerge
from portage.cache.cache_errors import CacheError, StatCollision
from portage.util import writemsg_level

def parse_args(args):
	usage = "egencache [options] --update [atom] ..."
	parser = optparse.OptionParser(usage=usage)
	parser.add_option("--update",
		action="store_true",
		help="update metadata/cache/ (generate as necessary)")
	parser.add_option("--cache-dir",
		help="location of the metadata cache",
		dest="cache_dir")
	parser.add_option("--config-root",
		help="location of portage config files",
		dest="config_root")
	parser.add_option("--jobs",
		action="store",
		help="max ebuild processes to spawn")
	parser.add_option("--load-average",
		action="store",
		help="max load allowed when spawning multiple jobs",
		dest="load_average")
	parser.add_option("--rsync",
		action="store_true",
		help="enable rsync stat collision workaround " + \
			"for bug 139134 (use with --update)")
	options, args = parser.parse_args(args)

	if not options.update:
		parser.error('No action specified (--update ' + \
			'is the only available action)')

	if options.config_root is not None and \
		not os.path.isdir(options.config_root):
		parser.error("Not a directory: --config-root='%s'" % \
			(options.config_root,))

	if options.cache_dir is not None and not os.path.isdir(options.cache_dir):
		parser.error("Not a directory: --cache-dir='%s'" % \
			(options.cache_dir,))

	for atom in args:
		try:
			atom = portage.dep.Atom(atom)
		except portage.exception.InvalidAtom:
			parser.error('Invalid atom: %s' % (atom,))

		if str(atom) != atom.cp:
			parser.error('Atom is too specific: %s' % (atom,))

	return options, args

class GenCache(object):
	def __init__(self, portdb, cp_iter=None, max_jobs=None, max_load=None,
		rsync=False):
		self._portdb = portdb
		# We can globally cleanse stale cache only if we
		# iterate over every single cp.
		self._global_cleanse = cp_iter is None
		if cp_iter is not None:
			self._cp_set = set(cp_iter)
			cp_iter = iter(self._cp_set)
		else:
			self._cp_set = None
		self._regen = _emerge.MetadataRegen(portdb, cp_iter=cp_iter,
			consumer=self._metadata_callback,
			max_jobs=max_jobs, max_load=max_load)
		self.returncode = os.EX_OK
		metadbmodule = portdb.mysettings.load_best_module("portdbapi.metadbmodule")
		self._trg_cache = metadbmodule(portdb.porttree_root,
			"metadata/cache", portage.auxdbkeys[:])
		if rsync:
			self._trg_cache.raise_stat_collision = True
		self._existing_nodes = set()

	def _metadata_callback(self, cpv, ebuild_path, repo_path, metadata):
		self._existing_nodes.add(cpv)
		if metadata is not None:
			if metadata.get('EAPI') == '0':
				del metadata['EAPI']
			try:
				try:
					self._trg_cache[cpv] = metadata
				except StatCollision, sc:
					# If the content of a cache entry changes and neither the
					# file mtime nor size changes, it will prevent rsync from
					# detecting changes. Cache backends may raise this
					# exception from _setitem() if they detect this type of stat
					# collision. These exceptions are be handled by bumping the
					# mtime on the ebuild (and the corresponding cache entry).
					# See bug #139134.
					max_mtime = sc.mtime
					for ec, (loc, ec_mtime) in metadata['_eclasses_'].iteritems():
						if max_mtime < ec_mtime:
							max_mtime = ec_mtime
					if max_mtime == sc.mtime:
						max_mtime += 1
					max_mtime = long(max_mtime)
					try:
						os.utime(ebuild_path, (max_mtime, max_mtime))
					except OSError, e:
						self.returncode |= 1
						writemsg_level(
							"%s writing target: %s\n" % (cpv, e),
							level=logging.ERROR, noiselevel=-1)
					else:
						metadata['_mtime_'] = max_mtime
						self._trg_cache[cpv] = metadata
						self._portdb.auxdb[repo_path][cpv] = metadata

			except CacheError, ce:
				self.returncode |= 1
				writemsg_level(
					"%s writing target: %s\n" % (cpv, ce),
					level=logging.ERROR, noiselevel=-1)

	def run(self):
		self._regen.run()
		self.returncode |= self._regen.returncode

		trg_cache = self._trg_cache
		dead_nodes = None
		if self._global_cleanse:
			try:
				dead_nodes = set(trg_cache.iterkeys())
			except CacheError, ce:
				self.returncode |= 1
				writemsg_level(
					"Error listing cache entries for " + \
					"'%s/metadata/cache': %s, continuing...\n" % \
					(self._portdb.porttree_root, ce),
					level=logging.ERROR, noiselevel=-1)

		else:
			cp_set = self._cp_set
			cpv_getkey = portage.cpv_getkey
			try:
				dead_nodes = set(cpv for cpv in \
					trg_cache.iterkeys() \
					if cpv_getkey(cpv) in cp_set)
			except CacheError, ce:
				self.returncode |= 1
				writemsg_level(
					"Error listing cache entries for " + \
					"'%s/metadata/cache': %s, continuing...\n" % \
					(self._portdb.porttree_root, ce),
					level=logging.ERROR, noiselevel=-1)

		if dead_nodes:
			dead_nodes.difference_update(self._existing_nodes)
			for k in dead_nodes:
				try:
					del trg_cache[k]
				except KeyError:
					pass
				except CacheError:
					self.returncode |= 1

		if not trg_cache.autocommits:
			try:
				trg_cache.commit()
			except CacheError, ce:
				self.returncode |= 1
				writemsg_level(
					"committing target: %s\n" % (ce,),
					level=logging.ERROR, noiselevel=-1)

def egencache_main(args):
	options, args = parse_args(args)

	config_root = options.config_root
	if config_root is None:
		config_root = '/'

	# The calling environment is ignored, so the program is
	# completely controlled by commandline arguments.
	env = {}

	# TODO: Implement --repo for choosing a repo.
	env['PORTDIR_OVERLAY'] = ''

	if options.cache_dir is not None:
		env['PORTAGE_DEPCACHEDIR'] = options.cache_dir

	settings = portage.config(config_root=config_root,
		target_root='/', env=env)

	if 'metadata-transfer' not in settings.features:
		writemsg_level("ecachegen: error: " + \
			"FEATURES=metadata-transfer is not enabled\n",
			level=logging.ERROR, noiselevel=-1)
		return 1

	portdb = portage.portdbapi(settings["PORTDIR"], mysettings=settings)

	cp_iter = None
	if args:
		cp_iter = iter(args)

	gen_cache = GenCache(portdb, cp_iter=cp_iter,
		max_jobs=options.jobs,
		max_load=options.load_average,
		rsync=options.rsync)
	gen_cache.run()
	return gen_cache.returncode

if __name__ == "__main__":
	portage._disable_legacy_globals()
	portage.util.noiselimit = -1
	sys.exit(egencache_main(sys.argv[1:]))
