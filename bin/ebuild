#!/usr/bin/python -O
# Copyright 1999-2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-src/portage/bin/ebuild,v 1.18.2.3 2005/05/07 04:32:59 ferringb Exp $

import getopt, os, sys

if len(sys.argv) <= 2:
	print "Usage: ebuild <ebuild file> <command> [command] ..."
	print ""
	print "See the ebuild(1) man page for more info"
	sys.exit(1)


opts, pargs = getopt.getopt(sys.argv[1:], '', ['debug', 'force'])
debug = ("--debug",'') in opts
force = ("--force",'') in opts

if "merge" in pargs:
	print "Disabling noauto in features... merge disables it. (qmerge doesn't)"
	os.environ["FEATURES"] = os.environ.get("FEATURES", "") + " -noauto"

os.environ["PORTAGE_CALLER"]="ebuild"
try:
	import portage
except ImportError:
	from os import path as osp
	sys.path.insert(0, osp.join(osp.dirname(osp.dirname(osp.realpath(__file__))), "pym"))
	import portage

import portage.util, portage.const
import portage.dep
portage.dep._dep_check_strict = True

# do this _after_ 'import portage' to prevent unnecessary tracing
if debug and "python-trace" in portage.features:
	import portage.debug
	portage.debug.set_trace(True)

if portage.settings["NOCOLOR"] in ("yes","true") or not sys.stdout.isatty():
	portage.output.nocolor()

ebuild = pargs.pop(0)
if not os.path.isabs(ebuild):
	mycwd = os.getcwd()
	# Try to get the non-canonical path from the PWD evironment variable, since
	# the canonical path returned from os.getcwd() may may be unusable in
	# cases where the directory stucture is built from symlinks.
	if "PWD" in os.environ and os.environ["PWD"] != mycwd and \
		os.path.realpath(os.environ["PWD"]) == mycwd:
		mycwd = portage.normalize_path(os.environ["PWD"])
	ebuild = os.path.join(mycwd, ebuild)
ebuild = portage.normalize_path(ebuild)
# portdbapi uses the canonical path for the base of the portage tree, but
# subdirectories of the base can be built from symlinks (like crossdev does).
ebuild_portdir = os.path.realpath(os.path.dirname(os.path.dirname(ebuild)))
ebuild = os.path.join(ebuild_portdir, *ebuild.split(os.path.sep)[-2:])

if not os.path.exists(ebuild):
	print "'%s' does not exist." % ebuild
	sys.exit(1)

ebuild_split = ebuild.split("/")
del ebuild_split[-2]
cpv = "/".join(ebuild_split[-2:])[:-7]

if not portage.catpkgsplit(cpv):
	print "!!! %s does not follow correct package syntax." % (cpv)
	sys.exit(1)

if ebuild.startswith(portage.root + portage.const.VDB_PATH):
	mytree = "vartree"

	portage_ebuild = portage.db[portage.root][mytree].dbapi.findname(cpv)

	if os.path.realpath(portage_ebuild) != ebuild:
		print "!!! Portage seems to think that %s is at %s" % (cpv, portage_ebuild)
		sys.exit(1)

else:
	mytree = "porttree"

	portage_ebuild = portage.portdb.findname(cpv)

	if not portage_ebuild or portage_ebuild != ebuild:
		overlay = "/".join(ebuild_split[:-2])
		os.environ["PORTDIR_OVERLAY"] = os.environ.get("PORTDIR_OVERLAY","") + " " + overlay
		print "Appending %s to PORTDIR_OVERLAY..." % overlay
		portage.close_portdbapi_caches()
		reload(portage)
		portage_ebuild = portage.portdb.findname(cpv)

		if not portage_ebuild or portage_ebuild != ebuild:
			print "!!! %s does not seem to have a valid PORTDIR structure." % overlay
			sys.exit(1)


if len(pargs) > 1 and "config" in pargs:
	print "config must be called on it's own, not combined with any other phase"
	sys.exit(1)

def discard_digests(myebuild, mysettings, mydbapi):
	"""Discard all distfiles digests for the given ebuild.  This is useful when
	upstream has changed the identity of the distfiles and the user would
	otherwise have to manually remove the Manifest and files/digest-* files in
	order to ensure correct results."""
	try:
		portage._doebuild_manifest_exempt_depend += 1
		pkgdir = os.path.dirname(myebuild)
		fetchlist_dict = portage.FetchlistDict(pkgdir, mysettings, mydbapi)
		cat, pkg = pkgdir.split(os.sep)[-2:]
		cpv = cat + "/" + os.path.basename(myebuild)[:-7]
		from portage.manifest import Manifest
		mf = Manifest(pkgdir, mysettings["DISTDIR"],
			fetchlist_dict=fetchlist_dict)
		mf.create(requiredDistfiles=None,
			assumeDistHashesSometimes=True, assumeDistHashesAlways=True)
		distfiles = fetchlist_dict[cpv]
		for myfile in distfiles:
			try:
				del mf.fhashdict["DIST"][myfile]
			except KeyError:
				pass
		mf.write()
	finally:
		portage._doebuild_manifest_exempt_depend -= 1

tmpsettings = portage.config(clone=portage.settings)
if "test" in pargs and "test" not in tmpsettings.features:
	print "Forcing test."
	tmpsettings["EBUILD_FORCE_TEST"] = "1"
	tmpsettings.backup_changes("EBUILD_FORCE_TEST")
	tmpsettings.features.append("test")
	tmpsettings["FEATURES"] = " ".join(tmpsettings.features)
	tmpsettings.backup_changes("FEATURES")

for arg in pargs:
	try:
		if arg == "digest" and force:
			discard_digests(ebuild, tmpsettings, portage.portdb)
		a = portage.doebuild(ebuild, arg, portage.root, tmpsettings,
			debug=debug, tree=mytree)
	except KeyboardInterrupt:
		print "Interrupted."
		a = 1
	except KeyError:
		# aux_get error
		a = 1
	if a == None:
		print "Could not run the required binary?"
		a = 127
	if a:
		sys.exit(a)
