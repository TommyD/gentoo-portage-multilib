#!/usr/bin/python2.2
# Copyright 1999-2003 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License v2
# $Header$

# Next to do: dep syntax checking in mask files
# Then, check to make sure deps are satisfiable (to avoid "can't find match for" problems)
# that last one is tricky because multiple profiles need to be checked.

import os,sys,string,signal,readline,portage,re
from output import *
from commands import getstatusoutput

exename=os.path.basename(sys.argv[0])	
version="1.2"	

def err(txt):
	print exename+": "+txt
	sys.exit(1)

def exithandler(signum=None,frame=None):
	sys.stderr.write("\n"+exename+": Interrupted; exiting...\n")
	sys.exit(1)
	os.kill(0,signal.SIGKILL)
signal.signal(signal.SIGINT,exithandler)

REPOROOTS=["gentoo-x86"]
modes=["scan","fix","full","help","commit"]
shortmodes={"ci":"commit"}
modeshelp={
"scan"  :"Scan current directory tree for QA issues (default)",
"fix"   :"Fix those issues that can be fixed (stray digests, missing digests)",
"full"  :"Scan current directory tree for QA issues (full listing)",
"help"  :"Show this screen",
"commit":"Scan current directory tree for QA issues; if OK, commit via cvs"
}
options=["--pretend","--help","--commitmsg","--commitmsgfile"]
optionshelp={
"--pretend":"Don't actually perform commit or fix steps; just show what would be done.",
"--help"   :"Show this screen",
"--commitmsg"    :"Adds a commit message on the command line.",
"--commitmsgfile":"Adds a commit message from file on the command line."
}
qacats=["digest.stray","digest.missing","ebuild.invalidname","ebuild.namenomatch","changelog.missing",
"ebuild.notadded","digest.notadded","ebuild.disjointed","digest.disjointed", "DEPEND.bad","RDEPEND.bad",
"DEPEND.badmasked","RDEPEND.badmasked","ebuild.syntax","ebuild.output","ebuild.nesteddie","LICENSE.invalid",
"IUSE.invalid","KEYWORDS.invalid"]
qawarnings=["changelog.missing","ebuild.notadded","digest.notadded","DEPEND.badmasked","RDEPEND.badmasked",
"IUSE.invalid"]
missingvars=["KEYWORDS","LICENSE","DESCRIPTION","SLOT"]
allvars=portage.auxdbkeys
commitmessage=None
commitmessagefile=None
for x in missingvars:
	qacats.append(x+".missing")
	qawarnings.append(x+".missing")
qahelp={
	"digest.stray":"Digest files that do not have a corresponding ebuild",
	"digest.missing":"Digest files that are missing (ebuild exists, digest doesn't)",
	"ebuild.invalidname":"Ebuild files with a non-parseable or syntactically incorrect name",
	"ebuild.namenomatch":"Ebuild files that do not have the same name as their parent directory",
	"changelog.missing":"Missing ChangeLog files",
	"ebuild.disjointed":"Ebuilds not added to cvs when the matching digest has been added",
	"digest.disjointed":"Digests not added to cvs when the matching ebuild has been added",
	"digest.notadded":"Digests that exist but have not been added to cvs",
	"ebuild.notadded":"Ebuilds that exist but have not been added to cvs",
	"KEYWORDS.missing":"Ebuilds that have a missing KEYWORDS variable",
	"LICENSE.missing":"Ebuilds that have a missing LICENSE variable",
	"DESCRIPTION.missing":"Ebuilds that have a missing DESCRIPTION variable",
	"SLOT.missing":"Ebuilds that have a missing SLOT variable",
	"DEPEND.bad":"User-visible ebuilds with bad DEPEND settings (matched against *visible* ebuilds)",
	"RDEPEND.bad":"User-visible ebuilds with bad RDEPEND settings (matched against *visible* ebuilds)",
	"DEPEND.badmasked":"Masked ebuilds with bad DEPEND settings (matched against *all* ebuilds)",
	"RDEPEND.badmasked":"Masked ebuilds with RDEPEND settings (matched against *all* ebuilds)",
	"ebuild.syntax":"Error generating cache entry for ebuild; typically caused by ebuild syntax error",
	"ebuild.output":"A simple sourcing of the ebuild produces output; this breaks ebuild policy.",
	"ebuild.nesteddie":"Placing 'die' inside ( ) prints an error, but doesn't stop the ebuild.",
	"IUSE.invalid":"This build has a variable in IUSE that is not in the use.desc or use.local.desc file",
	"LICENSE.invalid":"This ebuild is listing a license that doesnt exist in portages license/ dir.",
	"KEYWORDS.invalid":"This ebuild contains KEYWORDS that are not listed in profiles/keywords.desc"
}

def err(txt):
	print exename+": "+txt
	sys.exit(1)


ven_cat = r'[\w0-9-]+'                                # Category
ven_nam = r'([+a-z0-9-]+)'                            # Name
ven_ver = r'((?:\d+\.)*\d+[a-z]?)'                    # Version
ven_suf = r'(_(alpha\d*|beta\d*|pre\d*|rc\d*|p\d+))?' # Suffix
ven_rev = r'(-r\d+)?'                                 # Revision
	
ven_string=ven_cat+'/'+ven_nam+'-'+ven_ver+ven_suf+ven_rev
valid_ebuild_name_re=re.compile(ven_string+'$', re.I)
valid_ebuild_filename_re=re.compile(ven_string+'\.ebuild$', re.I)

def valid_ebuild_name(name):
	"""(name) --- Checks to ensure that the package name meets portage specs.
	Return 1 if valid, 0 if not."""
	# Handle either a path to the ebuild, or cat/pkg-ver string
	if (len(name) > 7) and (name[-7:] == ".ebuild"):
		if valid_ebuild_filename_re.match(name):
			return 1
	else:
		if valid_ebuild_name_re.match(name):
			return 1
	return 0


def help():
	print
	print green(exename+" "+version)
	print " \"Quality is job zero.\""
	print " Copyright 1999-2003 Gentoo Technologies, Inc."
	print " Distributed under the terms of the GNU General Public License v2"
	print
	print bold(" Usage:"),turquoise(exename),"[",green("option"),"] [",green("mode"),"]"
	print bold(" Modes:"),turquoise("scan (default)"),
	for x in modes[1:]:
		print "|",turquoise(x),
	print "\n"
	print " "+green(string.ljust("Option",20)+" Description")
	for x in options:
		print " "+string.ljust(x,20),optionshelp[x]
	print
	print " "+green(string.ljust("Mode",20)+" Description")
	for x in modes:
		print " "+string.ljust(x,20),modeshelp[x]
	print
	print " "+green(string.ljust("QA keyword",20)+" Description")
	for x in qacats:
		print " "+string.ljust(x,20),qahelp[x]
	print
	sys.exit(1)


mymode=None
myoptions=[]
if len(sys.argv)>1:
	x=1
	while x < len(sys.argv):
		if sys.argv[x] in shortmodes.keys():
			sys.argv[x]=shortmodes[sys.argv[x]]
		if sys.argv[x] in modes:
			if mymode==None:
				mymode=sys.argv[x]
			else:
				err("Please specify either \""+mymode+"\" or \""+sys.argv[x]+"\", but not both.")
		elif sys.argv[x] in options:
			if (sys.argv[x]=="--commitmsg") and (len(sys.argv)>=(x+1)):
				commitmessage=sys.argv[x+1]
				x=x+1
			elif (sys.argv[x]=="--commitmsgfile") and (len(sys.argv)>=(x+1)):
				commitmessage=sys.argv[x+1]
				x=x+1
			elif sys.argv[x] not in myoptions:
				myoptions.append(sys.argv[x])
		else:
			err("\""+sys.argv[x]+"\" is not a valid mode or option.")
		x=x+1
if mymode==None:
	mymode="scan"
if mymode=="help" or ("--help" in myoptions):
	help()

if not os.path.isdir("CVS"):
	err("We do not appear to be inside a local repository. Exiting.")
try:
	myrepofile=open("CVS/Repository")
	myreporoot=myrepofile.readline()[:-1]
	myrepofile.close()
except:
	err("Error grabbing repository information; exiting.")

try: # Determine if we're in PORTDIR... If not tell portage to accomodate.
	mydir=os.getcwd()
	if portage.settings["PORTDIR"][-1]!="/":
		portage.settings["PORTDIR"]=portage.settings["PORTDIR"]+"/"
	if portage.settings["PORTDIR"]!=mydir[:len(portage.settings["PORTDIR"])]:
		# We're not in the PORTDIR
		print
		print darkred("We're not in PORTDIR..."),
		while mydir!="/":
			if os.path.exists(mydir+"/profiles/package.mask"):
				# mydir == a PORTDIR root... We make PORTDIR = mydir.
				print darkgreen("setting to:")+" "+bold(mydir)
				os.environ["PORTDIR"]=mydir
				break;
			else:
				mydir=os.path.normpath(mydir+"/..")
		if mydir=="/":
			print darkred("unable to determine a PORTDIR.")
except Exception, e:
	print "!!! Error when determining valid(ity of) PORTDIR:"
	print "!!!",e
	pass
os.environ["REPOMAN"]="running"
reload(portage)

reporoot=None
for x in REPOROOTS:
	if myreporoot[0:len(x)]==x:
		reporoot=myreporoot
if not reporoot:
	err("Couldn't recognize repository type.  Supported repositories:\n"+repr(REPOROOTS))
reposplit=string.split(myreporoot,"/")
repolevel=len(reposplit)
startdir=os.getcwd()
for x in range(0,repolevel-1):
	os.chdir("..")
repodir=os.getcwd()
os.chdir(startdir)
def caterror(mycat):
	err(mycat+" is not an official category.  Skipping QA checks in this directory.\nPlease ensure that you add "+catdir+" to "+repodir+"/profiles/categories\nif it is a new category.")
print
if "--pretend" in myoptions:
	print green("RepoMan pretends to scour the neighborhood...")
else:
	print green("RepoMan scours the neighborhood...")

# retreive local USE list
luselist=[]
try:
	mylist=portage.grabfile(portage.settings["PORTDIR"]+"/profiles/use.local.desc")
	for mypos in range(0,len(mylist)):
		mysplit=mylist[mypos].split()[0]
		myuse=string.split(mysplit,":")
		if myuse==2:
			luselist.append(myuse[1])
except:
	err("Couldn't read from use.local.desc")

# setup a uselist from portage
uselist=[]
try:
	uselist=portage.grabfile(portage.settings["PORTDIR"]+"/profiles/use.desc")
	for l in range(0,len(uselist)):
		uselist[l]=string.split(uselist[l])[0]
except:
	err("Couldn't read USE flags from use.desc")

uselist=uselist+luselist

# retreive a list of current licenses in portage
liclist=portage.listdir(portage.settings["PORTDIR"]+"/licenses")
if not liclist:
	err("Couldn't find licenses?")

# retreive list of offiial keywords
try:
	kwlist=portage.grabfile(portage.settings["PORTDIR"]+"/profiles/keywords.desc")
except:
	err("Couldn't read KEYWORDS from keywords.desc")
if not kwlist:
	kwlist=["alpha","arm","hppa","mips","ppc","sparc","x86"]
	for pos in range(0,len(kwlist)):
		kwlist+=["~"+kwlist[pos]]

scanlist=[]
if repolevel==2:
	#we are inside a category directory
	catdir=reposplit[-1]
	if catdir not in portage.categories:
		caterror(catdir)
	mydirlist=os.listdir(startdir)
	for x in mydirlist:
		if x=="CVS":
			continue
		if os.path.isdir(startdir+"/"+x):
			scanlist.append(catdir+"/"+x)
elif repolevel==1:
	for x in portage.categories:
		if not os.path.isdir(startdir+"/"+x):
			continue
		for y in os.listdir(startdir+"/"+x):
			if y=="CVS":
				continue
			if os.path.isdir(startdir+"/"+x+"/"+y):
				scanlist.append(x+"/"+y)
elif repolevel==3:
	catdir = reposplit[-2]
	if catdir not in portage.categories:
		caterror(catdir)
	scanlist.append(catdir+"/"+reposplit[-1])

stats={}
fails={}
#objsadded records all object being added to cvs
objsadded=[]
for x in qacats:
	stats[x]=0
	fails[x]=[]
for x in scanlist:
	#ebuilds and digests added to cvs respectively.
	eadded=[]
	dadded=[]
	catdir,pkgdir=x.split("/")
	checkdir=repodir+"/"+x
	checkdirlist=os.listdir(checkdir)
	ebuildlist=[]
	for y in checkdirlist:
		if y[-7:]==".ebuild":
			ebuildlist.append(y[:-7])
	digestlist=[]
	try:
		myf=open(checkdir+"/CVS/Entries","r")
		myl=myf.readlines()
		for l in myl:
			if l[0]!="/":
				continue
			splitl=l[1:].split("/")
			if not len(splitl):
				continue
			objsadded.append(splitl[0])
			if splitl[0][-7:]==".ebuild":
				eadded.append(splitl[0][:-7])
	except IOError:
		continue
	try:
		myf=open(checkdir+"/files/CVS/Entries","r")
		myl=myf.readlines()
		for l in myl:
			if l[0]!="/":
				continue
			splitl=l[1:].split("/")
			if not len(splitl):
				continue
			objsadded.append(splitl[0])
			if splitl[0][:7]=="digest-":
				dadded.append(splitl[0][7:])
	except IOError:
		continue
	if os.path.exists(checkdir+"/files"):
		filesdirlist=os.listdir(checkdir+"/files")
		for y in filesdirlist:
			if y[:7]=="digest-":
				if y[7:] not in dadded:
					#digest not added to cvs
					stats["digest.notadded"]=stats["digest.notadded"]+1
					fails["digest.notadded"].append(x+"/files/"+y)
					if y[7:] in eadded:
						stats["digest.disjointed"]=stats["digest.disjointed"]+1
						fails["digest.disjointed"].append(x+"/files/"+y)
				if y[7:] not in ebuildlist:
					#stray digest
					if mymode=="fix":
						if "--pretend" in myoptions:
							print "(cd "+repodir+"/"+x+"/files; cvs rm -f "+y+")"
						else:
							os.system("(cd "+repodir+"/"+x+"/files; cvs rm -f "+y+")")					
					else:
						stats["digest.stray"]=stats["digest.stray"]+1
						fails["digest.stray"].append(x+"/files/"+y)
					
	if not "ChangeLog" in checkdirlist:
		stats["changelog.missing"]=stats["changelog.missing"]+1
		fails["changelog.missing"].append(x+"/ChangeLog")
	for y in ebuildlist:
		if y not in eadded:
			#ebuild not added to cvs
			stats["ebuild.notadded"]=stats["ebuild.notadded"]+1
			fails["ebuild.notadded"].append(x+"/"+y+".ebuild")
			if y in dadded:
				stats["ebuild.disjointed"]=stats["ebuild.disjointed"]+1
				fails["ebuild.disjointed"].append(x+"/"+y+".ebuild")
		if not os.path.exists(checkdir+"/files/digest-"+y):
			if mymode=="fix":
				if "--pretend" in myoptions:
					print "/usr/sbin/ebuild "+repodir+"/"+x+"/"+y+".ebuild digest"
				else:
					os.system("/usr/sbin/ebuild "+repodir+"/"+x+"/"+y+".ebuild digest")
			else:
				stats["digest.missing"]=stats["digest.missing"]+1
				fails["digest.missing"].append(x+"/files/digest-"+y)
		myesplit=portage.pkgsplit(y)
		if myesplit==None or not valid_ebuild_name(x.split("/")[0]+"/"+y):
			stats["ebuild.invalidname"]=stats["ebuild.invalidname"]+1
			fails["ebuild.invalidname"].append(x+"/"+y+".ebuild")
			continue
		elif myesplit[0]!=pkgdir:
			print pkgdir,myesplit[0]
			stats["ebuild.namenomatch"]=stats["ebuild.namenomatch"]+1
			fails["ebuild.namenomatch"].append(x+"/"+y+".ebuild")
			continue
		try:
			myaux=portage.db["/"]["porttree"].dbapi.aux_get(catdir+"/"+y,allvars,strict=1)
		except KeyError:
			stats["ebuild.syntax"]=stats["ebuild.syntax"]+1
			fails["ebuild.syntax"].append(x+"/"+y+".ebuild")
			continue
		except IOError:
			stats["ebuild.output"]=stats["ebuild.output"]+1
			fails["ebuild.output"].append(x+"/"+y+".ebuild")
			continue
		for pos in range(0,len(missingvars)):
			if portage.db["/"]["porttree"].dbapi.aux_get(catdir+"/"+y, [ missingvars[pos] ] )[0]=="":
				myqakey=missingvars[pos]+".missing"
				stats[myqakey]=stats[myqakey]+1
				fails[myqakey].append(x+"/"+y+".ebuild")
		if not catdir+"/"+y in portage.db["/"]["porttree"].dbapi.xmatch("list-visible",x):
			#we are testing deps for a masked package; give it some lee-way
			suffix="masked"
			matchmode="match-all"
		else:
			suffix=""
			matchmode="match-visible"
		for mytype,mypos in [["DEPEND",len(missingvars)],["RDEPEND",len(missingvars)+1]]:
			mykey=mytype+".bad"+suffix
			myvalue=string.join(portage.db["/"]["porttree"].dbapi.aux_get(catdir+"/"+y,[ mytype ]))
			mydep=portage.dep_check(myvalue,portage.db["/"]["porttree"].dbapi,use="all",mode=matchmode)
			if mydep[0]==1:
				if mydep[1]!=[]:
					#we have some unsolvable deps
					#remove ! deps, which always show up as unsatisfiable
					d=0
					while d<len(mydep[1]):
						if mydep[1][d][0]=="!":
							del mydep[1][d]
						else:
							d += 1
					#if we emptied out our list, continue:
					if not mydep[1]:
						continue
					stats[mykey]=stats[mykey]+1
					fails[mykey].append(x+"/"+y+".ebuild: "+repr(mydep[1]))
			else:
					stats[mykey]=stats[mykey]+1
					fails[mykey].append(x+"/"+y+".ebuild: "+repr(mydep[1]))
		if not os.system("egrep '\([^)]*\<die\>' "+checkdir+"/"+y+".ebuild >/dev/null 2>&1"):
			stats["ebuild.nesteddie"]=stats["ebuild.nesteddie"]+1
			fails["ebuild.nesteddie"].append(x+"/"+y+".ebuild")
		# uselist checks - global and local
		myuse=string.split(portage.db["/"]["porttree"].dbapi.aux_get(catdir+"/"+y,["IUSE"])[0])
		for mypos in range(0,len(myuse)):
			if myuse[mypos] and (myuse[mypos] not in uselist):
				stats["IUSE.invalid"]=stats["IUSE.invalid"]+1
				fails["IUSE.invalid"].append(x+"/"+y+".ebuild: %s" % myuse[mypos])	
		#license checks
		myuse=string.split(portage.db["/"]["porttree"].dbapi.aux_get(catdir+"/"+y,["LICENSE"])[0])
		for mypos in range(0,len(myuse)):
			if not myuse[mypos] in liclist and myuse[mypos] != "|":
				stats["LICENSE.invalid"]=stats["LICENSE.invalid"]+1
				fails["LICENSE.invalid"].append(x+"/"+y+".ebuild: %s" % myuse[mypos])
		#keyword checks
		myuse=string.split(portage.db["/"]["porttree"].dbapi.aux_get(catdir+"/"+y,["KEYWORDS"])[0])
		for mypos in range(0,len(myuse)):
			if not myuse[mypos].strip("~-") in kwlist:
				stats["KEYWORDS.invalid"]=stats["KEYWORDS.invalid"]+1
				fails["KEYWORDS.invalid"].append(x+"/"+y+".ebuild: %s" % myuse[mypos])

print
#dofail will be set to 1 if we have failed in at least one non-warning category
dofail=0
#dowarn will be set to 1 if we tripped any warnings
dowarn=0
#dofull will be set if we should print a "repoman full" informational message
dofull=0
for x in qacats:
	if stats[x]:
		dowarn=1
		if x not in qawarnings:
			dofail=1
	else:
		if mymode!="full":
			continue
	print "  "+string.ljust(x,20),
	if stats[x]==0:
		print green(`stats[x]`)
		continue
	elif x in qawarnings:
		print yellow(`stats[x]`)
	else:
		print red(`stats[x]`)
	if mymode!="full":
		if stats[x]<12:
			for y in fails[x]:
				print "   "+y
		else:
			dofull=1
	else:
		for y in fails[x]:
			print "   "+y
print


def grouplist(mylist,seperator="/"):
	"""(list,seperator="/") -- Takes a list of elements; groups them into
	same initial element categories. Returns a dict of {base:[sublist]}
	From: ["blah/foo","spork/spatula","blah/weee/splat"]
	To:   {"blah":["foo","weee/splat"], "spork":["spatula"]}"""
	mygroups={}
	for x in mylist:
		xs=string.split(x,seperator)
		if xs[0] not in mygroups.keys():
			mygroups[xs[0]]=[string.join(xs[1:],seperator)]
		else:
			mygroups[xs[0]]+=[string.join(xs[1:],seperator)]
	return mygroups

def doall(myheaders,basepath=""):
	mychanges=[]
	mydirs=grouplist(myheaders)
	for x in mydirs.keys():
		if x not in portage.categories:
			print "!!! Changes in a non-category directory being ignored."
			print "!!! Dir:",x
		else:
			os.chdir(x)
			for y in docatdir(mydirs[x],x):
				mychanges+=[x+"/"+y]
			os.chdir("..")
	return mychanges

def docatdir(myheaders,basepath=""):
	mychanges=[]
	mydirs=grouplist(myheaders)
	#print mydirs
	for x in mydirs.keys():
		if os.path.isdir(x):
			os.chdir(x)                           # Change into package dir
			mydirchanges=[]
			#print "mydirs:",mydirs
			for myfile in mydirs[x]:
				#print "**myfile:",myfile
				mydirchanges+=dopkgdir([myfile],basepath+x)
			for y in mydirchanges:
				mychanges+=[x+"/"+y]
			os.chdir("..")                        # Leave package dir
		else:
			print red("!!! File exists in a category dir, but outside a package.")
			print red("!!! File:"),bold(basepath+x)
	return mychanges

def dopkgdir(myheaders, basepath=""):
	mychanges=[]
	#print myheaders
	for x in myheaders:
		xs=x.split("/")
		if len(xs)==1:     # It's an ebuild, we hope.
			if xs[0][-len(".ebuild"):]==".ebuild":
				if x[:-len(".ebuild")] not in mychanges:
					mychanges.append(x[:-len(".ebuild")])
			else:
				print red("!!! File is not an ebuild but is in package root.")
				print red("!!! File:"),bold(basepath+x)
		else:
			# It should be in files/
			if xs[0]=="files":
				if (len(xs[1])>4) and xs[0][-4:]==".asc":
					print "!!! Why does an ascii signature have headers...?"
					print "!!! File:",basepath+x
				elif (len(xs[1])>7) and xs[1][:7]=="digest-":
					print "!!! Why does a digest have headers...?"
					print "!!! File:",basepath+x
				else:
					# All ebuilds because files/ changed
					for eb in portage.listdir(".", filesonly=1):
						#print "eblist:",eb
						if len(eb)>7 and eb[-len(".ebuild"):]==".ebuild":
							mychanges.append(eb[:-len(".ebuild")])
						elif eb=="ChangeLog":
							continue
						else:
							print red("!!! File is not an ebuild but is in package root.")
							print red("!!! File:"),bold(eb)
			else:
				print red("!!! File exists outside of files directory.")
				print red("!!! File:"),bold(basepath+x)
	return mychanges

if mymode!="commit":
	if dofull:
		print bold("Note: type \"repoman full\" for a complete listing.")
		print
	if dowarn and not dofail:
		print green("RepoMan sez:"),"\"You're only giving me a partial QA payment?\nI'll take it this time, but I'm not happy.\""
	elif not dofail:
		print green("RepoMan sez:"),"\"If everyone were like you, I'd be out of business!\""
	print
else:
	if dofail:
		print turquoise("Please fix these important QA issues first.")
		print green("RepoMan sez:"),"\"Make your QA payment on time and you'll never see the likes of me.\"\n"
		sys.exit(1)
	if "--pretend" in myoptions:
		print
		retval=os.system("/usr/bin/cvs -qn update")
		print
		print "Dry-run cvs update complete."
		print green("RepoMan sez:"), "\"So, you want to play it safe. Good call.\"\n"
	else:
		print "Checking in the tree:",reporoot
		mystatus=getstatusoutput('/usr/bin/cvs status 2>/dev/null | egrep "Status:|Repository revision:" | tr "\n" "\001" | sed \'s#File:[^\d001]*Status: \([^\d001]\+\)[^/]*[^ ]*/'+reporoot+'/\([^\d001]\+\),v#\\1 -=- \\2#g\' | tr "\001" "\n" | egrep -v \'^[:space:]*$\'')
		mylines=string.split(mystatus[1], "\n")
		if mystatus[0]:
			#print mylines
			print red("Failed to check the tree.")
			sys.exit(mystatus[0])
		myupdates=[]
		myheaders=[]
		mydirty=[]
		for line in mylines:
			if not line:
				continue
			mysplit=string.split(line," -=- ")
			#print portage.settings["PORTDIR"],mysplit
			if mysplit[0][:5]=="Needs" or mysplit[0][:5]=="Entry":
				mydirty.append(mysplit[1])

			elif mysplit[0]=="Up-to-date":
				#print ".",
				continue
			else:
				if len(mysplit)<2:
					if repolevel!=3:
						print "!!! There is a package that has not been added yet. Please add and commit"
						print "!!! it from it's directory."
						try:
							print "!!! See:",bold(string.split(mysplit[0],"\t")[0])
						except:
							pass
						sys.exit(1)
					myout=[0]
					mysplit=[0,string.split(string.split(mysplit[0],"\t")[1]," ")[1]]
				else:
					headerstart="'\$Header: "
					myout=getstatusoutput("egrep -q "+headerstart+"\$' "+mysplit[1])
				if myout[0]==0:
					myheaders.append(mysplit[1])
				myupdates.append(mysplit[1])
			#print line

		for x in myupdates:
			for y in mydirty:
				#print "dirties:",x,y
				if re.match(os.path.dirname(x),os.path.dirname(y)):
					print red("Some files are not up to date! Digests will be wrong")
					print red("for all packages in which these files are involved.")
					print green("/usr/bin/cvs status")
					print
					print green("RepoMan sez:"), "\"Ah ha! Thought you could sneak in a dirty commit, didn't you?\"\n"
					print
					for z in mydirty:
						print "Dirty:",z
					sys.exit(1)
		print "*",green(str(len(myupdates))),"files being committed...",green(str(len(myheaders))),"have headers that will change."
		print
		print myupdates
		print myheaders
		print "*","Files that have headers will be re-digested and the digests recommited."
		print
		unlinkfile=0
		if not (commitmessage or commitmessagefile):
			print "Please enter a CVS commit message at the prompt:"
			try:
				mycomment=raw_input(green("> "))
			except KeyboardInterrupt: 
				exithandler()
			# backslash any single quotes
			commitmessagefile="/tmp/.repoman.msg"
			mymsg=open(commitmessagefile,"w")
			mymsg.write(mycomment)
			mymsg.close()
		else:
			unlinkfile=0
			if commitmessagefile:
				unlinkfile=1
				try:
					mymsg=open(commitmessagefile,"r")
					mycomment=mymsg.read()
					mymsg.close()
				except Exception,e:
					print "!!! Failed to open commit message file."
					print "!!!",e
					sys.exit(1)
			else:
				mycomment=commitmessage
		print
		print green("Using commit message:")
		print green("------------------------------------------------------------------------------")
		print mycomment
		print green("------------------------------------------------------------------------------")
		print
		#retval=0
		retval=os.system("/usr/bin/cvs -q commit -F "+commitmessagefile)
		if retval:
			print "!!! Exiting on cvs (shell) error code:",retval
			sys.exit(retval)
		mychanges=[]
		#print myheaders
		if myheaders:
			if repolevel==3:   # In a package dir
				mychanges=dopkgdir(myheaders)
			elif repolevel==2: # In a category dir
				mychanges=docatdir(myheaders)
			elif repolevel==1: # repo-cvsroot
				print green("RepoMan sez:"), "\"You're rather crazy to do the entire repository.\"\n"
				mychanges=doall(myheaders)
			else:
				print red("I'm confused... I don't know where I am!")
				sys.exit(1)

		mysigs=[]
		for x in mychanges:
			#print "redigest:",x
			os.system("/usr/sbin/ebuild "+x+".ebuild digest")
			y = string.split(x,"/")
			if "sign" in portage.features:
				gpgcmd="gpg -ab --yes "+portage.settings["GPG_OPTIONS"]+" "
				sigfile=y[:-1]+"/files/digest-"+y[-1]
				os.system(gpgcmd+sigfile)
				mysigs+=[sigfile]
		
		if "sign" in portage.features:
			if os.system("/usr/bin/cvs -q add "+string.join(mysigs)):
				print red("!!! Seem to have had a problem adding the signatures...")
		retval=os.system("/usr/bin/cvs -q commit -F "+commitmessagefile)
		if retval:
			print "!!! Exiting on cvs (shell) error code:",retval
			sys.exit(retval)
		
		#print "myheaders:",myheaders
		#print "mychanges:",mychanges
		if unlinkfile:
			os.unlink(commitmessagefile)
		print
		print "CVS commit complete."
		print green("RepoMan sez:"), "\"If everyone were like you, I'd be out of business!\"\n"
	sys.exit(retval)
sys.exit(0)









