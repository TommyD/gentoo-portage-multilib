#!/usr/bin/python2.2
# Copyright 1999-2002 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License v2
# Author: Daniel Robbins <drobbins@gentoo.org>
# $Header$

# Next to do: dep syntax checking in ebuilds, mask files
# Then, check to make sure deps are satisfiable (to avoid "can't find match for" problems)
# that last one is tricky because multiple profiles need to be checked.

import os,sys,string,signal,portage,readline
from output import *
exename=os.path.basename(sys.argv[0])	
version="1.1"	

def err(txt):
	print exename+": "+txt
	sys.exit(1)

def exithandler(signum=None,frame=None):
	sys.stderr.write("\n"+exename+": Interrupted; exiting...\n")
	sys.exit(1)
	os.kill(0,signal.SIGKILL)
signal.signal(signal.SIGINT,exithandler)

REPOROOTS=["gentoo-x86"]
modes=["scan","fix","full","help","commit"]
shortmodes={"ci":"commit"}
options=["--pretend","--help"]
modeshelp={"scan":"Scan current directory tree for QA issues (default)",
"fix":"Fix those issues that can be fixed (stray digests, missing digests)",
"full":"Scan current directory tree for QA issues (full listing)",
"help":"Show this screen",
"commit":"Scan current directory tree for QA issues; if OK, commit via cvs" }
optionshelp={"--pretend":"Don't actually perform commit or fix steps; just show what would be done.",
"--help":"Show this screen"
}
qacats=["digest.stray","digest.missing","ebuild.invalidname","ebuild.namenomatch","changelog.missing","ebuild.notadded","digest.notadded","ebuild.disjointed","digest.disjointed"]
qawarnings=["changelog.missing","ebuild.notadded","digest.notadded"]
qahelp={
	"digest.stray":"Digest files that do not have a corresponding ebuild",
	"digest.missing":"Digest files that are missing (ebuild exists, digest doesn't)",
	"ebuild.invalidname":"Ebuild files with a non-parseable name",
	"ebuild.namenomatch":"Ebuild files that do not have the same name as their parent directory",
	"changelog.missing":"Missing ChangeLog files",
	"ebuild.disjointed":"Ebuilds not added to cvs when the matching digest has been added",
	"digest.disjointed":"Digests not added to cvs when the matching ebuild has been added",
	"digest.notadded":"Digests that exist but have not been added to cvs",
	"ebuild.notadded":"Ebuilds that exist but have not been added to cvs"
}

def err(txt):
	print exename+": "+txt
	sys.exit(1)

def help():
	print
	print green(exename+" "+version)
	print " \"Quality is job zero.\""
	print " Copyright 1999-2002 Gentoo Technologies, Inc."
	print " Distributed under the terms of the GNU General Public License v2"
	print
	print bold("Usage:"),turquoise(exename),"[",green("option"),"] [",green("mode"),"]"
	print bold("Modes:"),turquoise("scan (default)"),
	for x in modes[1:]:
		print "|",turquoise(x),
	print "\n"
	print " "+green(string.ljust("Option",20)+" Description")
	for x in options:
		print " "+string.ljust(x,20),optionshelp[x]
	print
	print " "+green(string.ljust("Mode",20)+" Description")
	for x in modes:
		print " "+string.ljust(x,20),modeshelp[x]
	print
	print " "+green(string.ljust("QA keyword",20)+" Description")
	for x in qacats:
		print " "+string.ljust(x,20),qahelp[x]
	print
	sys.exit(1)


mymode=None
myoptions=[]
if len(sys.argv)>1:
	for x in sys.argv[1:]:
		if x in shortmodes.keys():
			x=shortmodes[x]
		if x in modes:
			if mymode==None:
				mymode=x
			else:
				err("Please specify either \""+mymode+"\" or \""+x+"\", but not both.")
		elif x in options:
			if not x in myoptions:
				myoptions.append(x)
		else:
			err("\""+x+"\" is not a valid mode or option.")
if mymode==None:
	mymode="scan"
if mymode=="help" or ("--help" in myoptions):
	help()

if not os.path.isdir("CVS"):
	err("We do not appear to be inside a local repository. Exiting.")
try:
	myrepofile=open("CVS/Repository")
	myreporoot=myrepofile.readline()[:-1]
	myrepofile.close()
except:
	err("Error grabbing repository information; exiting.")
reporoot=None
for x in REPOROOTS:
	if myreporoot[0:len(x)]==x:
		reporoot=myreporoot
if not reporoot:
	err("Couldn't recognize repository type.  Supported repositories:\n"+repr(REPOROOTS))
reposplit=string.split(myreporoot,"/")
repolevel=len(reposplit)
startdir=os.getcwd()
for x in range(0,repolevel-1):
	os.chdir("..")
repodir=os.getcwd()
os.chdir(startdir)
def caterror(mycat):
	err(mycat+" is not an official category.  Skipping QA checks in this directory.\nPlease ensure that you add "+catdir+" to "+repodir+"/profiles/categories\nif it is a new category.")
print
if "--pretend" in myoptions:
	print green("RepoMan pretends to scour the neighborhood...")
else:
	print green("RepoMan scours the neighborhood...")
scanlist=[]
if repolevel==2:
	#we are inside a category directory
	catdir=reposplit[-1]
	if catdir not in portage.categories:
		caterror(catdir)
	mydirlist=os.listdir(startdir)
	for x in mydirlist:
		if x=="CVS":
			continue
		if os.path.isdir(startdir+"/"+x):
			scanlist.append(catdir+"/"+x)
elif repolevel==1:
	for x in portage.categories:
		if not os.path.isdir(startdir+"/"+x):
			continue
		for y in os.listdir(startdir+"/"+x):
			if y=="CVS":
				continue
			if os.path.isdir(startdir+"/"+x+"/"+y):
				scanlist.append(x+"/"+y)
elif repolevel==3:
	if reposplit[-2] not in portage.categories:
		caterror(catdir)
	scanlist.append(reposplit[-2]+"/"+reposplit[-1])

stats={}
fails={}
for x in qacats:
	stats[x]=0
	fails[x]=[]
for x in scanlist:
	#ebuilds and digests added to cvs respectively.
	eadded=[]
	dadded=[]
	catdir,pkgdir=x.split("/")
	checkdir=repodir+"/"+x
	checkdirlist=os.listdir(checkdir)
	ebuildlist=[]
	for y in checkdirlist:
		if y[-7:]==".ebuild":
			ebuildlist.append(y[:-7])
	digestlist=[]
	try:
		myf=open(checkdir+"/CVS/Entries","r")
		myl=myf.readlines()
		for l in myl:
			if l[0]!="/":
				continue
			splitl=l[1:].split("/")
			if not len(splitl):
				continue
			if splitl[0][-7:]==".ebuild":
				eadded.append(splitl[0][:-7])
	except IOError:
		continue
	try:
		myf=open(checkdir+"/files/CVS/Entries","r")
		myl=myf.readlines()
		for l in myl:
			if l[0]!="/":
				continue
			splitl=l[1:].split("/")
			if not len(splitl):
				continue
			if splitl[0][:7]=="digest-":
				dadded.append(splitl[0][7:])
	except IOError:
		continue
	if os.path.exists(checkdir+"/files"):
		filesdirlist=os.listdir(checkdir+"/files")
		for y in filesdirlist:
			if y[:7]=="digest-":
				if y[7:] not in dadded:
					#digest not added to cvs
					stats["digest.notadded"]=stats["digest.notadded"]+1
					fails["digest.notadded"].append(x+"/files/"+y)
					if y[7:] in eadded:
						stats["digest.disjointed"]=stats["digest.disjointed"]+1
						fails["digest.disjointed"].append(x+"/files/"+y)
				if y[7:] not in ebuildlist:
					#stray digest
					if mymode=="fix":
						if "--pretend" in myoptions:
							print "(cd "+repodir+"/"+x+"/files; cvs rm -f "+y+")"
						else:
							os.system("(cd "+repodir+"/"+x+"/files; cvs rm -f "+y+")")					
					else:
						stats["digest.stray"]=stats["digest.stray"]+1
						fails["digest.stray"].append(x+"/files/"+y)
					
	if not "ChangeLog" in checkdirlist:
		stats["changelog.missing"]=stats["changelog.missing"]+1
		fails["changelog.missing"].append(x+"/ChangeLog")
	for y in ebuildlist:
		if y not in eadded:
			#ebuild not added to cvs
			stats["ebuild.notadded"]=stats["ebuild.notadded"]+1
			fails["ebuild.notadded"].append(x+"/"+y+".ebuild")
			if y in dadded:
				stats["ebuild.disjointed"]=stats["ebuild.disjointed"]+1
				fails["ebuild.disjointed"].append(x+"/"+y+".ebuild")
		if not os.path.exists(checkdir+"/files/digest-"+y):
			if mymode=="fix":
				if "--pretend" in myoptions:
					print "/usr/sbin/ebuild "+repodir+"/"+x+"/"+y+".ebuild digest"
				else:
					os.system("/usr/sbin/ebuild "+repodir+"/"+x+"/"+y+".ebuild digest")
			else:
				stats["digest.missing"]=stats["digest.missing"]+1
				fails["digest.missing"].append(x+"/files/digest-"+y)
		myesplit=portage.pkgsplit(y)
		if myesplit==None:
			stats["ebuild.invalidname"]=stats["ebuild.invalidname"]+1
			fails["ebuild.invalidname"].append(x+"/"+y+".ebuild")
		elif myesplit[0]!=pkgdir:
			print pkgdir,myesplit[0]
			stats["ebuild.namenomatch"]=stats["ebuild.namenomatch"]+1
			fails["ebuild.namenomatch"].append(x+"/"+y+".ebuild")

print
for x in qacats:
	if stats[x]==0:
		print "  "+string.ljust(x,20),
	else:
		print "  "+bold(string.ljust(x,20)),
	if stats[x]==0:
		print green(`stats[x]`)
	elif x in qawarnings:
		print yellow(`stats[x]`)
	else:
		print red(`stats[x]`)
	if stats[x]==0:
		continue
	if mymode!="full":
		if stats[x]<12:
			for y in fails[x]:
				print "   >"+y
		else:
			print "   >("+`stats[x]`+" items; run in \"full\" mode for list.)"
	else:
		for y in fails[x]:
			print "   >"+y
print
if mymode=="commit":
	dofail=0
	for x in qacats:
		if stats[x] and (x not in qawarnings):
			dofail=1
			print turquoise(`stats[x]`+" "+x+" failures")
	if dofail:
		print turquoise("Please fix these important QA issues first.")
		print green("RepoMan sez:"),"\"Make your QA payment on time and you'll never see the likes of me.\"\n"
		sys.exit(1)
	if "--pretend" in myoptions:
		print
		retval=os.system("/usr/bin/cvs -qn update")
		print
		print "Dry-run cvs update complete."
		print green("RepoMan sez:"), "\"So, you want to play it safe. Good call.\"\n"
	else:
		print "Please enter a CVS commit message at the prompt:"
		try:
			mycomment=raw_input(green("> "))
		except KeyboardInterrupt: 
			exithandler()
		print
		retval=os.system("/usr/bin/cvs -q commit -m'"+mycomment+"'")
		print
		print "Cvs commit complete."
		print green("RepoMan sez:"), "\"If everyone were like you, I'd be out of business!\"\n"
	sys.exit(retval)
sys.exit(0)
