#!/usr/bin/python -O
# Copyright 1999-2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Id$

import sys
# This block ensures that ^C interrupts are handled quietly.
try:
	import signal

	def exithandler(signum,frame):
		signal.signal(signal.SIGINT, signal.SIG_IGN)
		signal.signal(signal.SIGTERM, signal.SIG_IGN)
		sys.exit(1)
	
	signal.signal(signal.SIGINT, exithandler)
	signal.signal(signal.SIGTERM, exithandler)
	signal.signal(signal.SIGPIPE, signal.SIG_DFL)

except KeyboardInterrupt:
	sys.exit(1)

import os, stat
os.environ["PORTAGE_CALLER"]="emerge"
sys.path = ["/usr/lib/portage/pym"]+sys.path

os.environ["PORTAGE_LEGACY_GLOBALS"] = "false"
import portage
del os.environ["PORTAGE_LEGACY_GLOBALS"]

import emergehelp, xpak, commands, errno, re, socket, string, time, types
from output import blue, bold, colorize, darkblue, darkgreen, darkred, green, \
	havecolor, nc_len, nocolor, red, teal, turquoise, white, xtermTitle, \
	xtermTitleReset, yellow
from output import create_color_func
good = create_color_func("GOOD")
bad = create_color_func("BAD")

import portage_util
import portage_locks
import portage_exception
from portage_data import secpass

if not hasattr(__builtins__, "set"):
	from sets import Set as set

class stdout_spinner(object):
	scroll_msgs = [
		"Gentoo Rocks ("+os.uname()[0]+")",
		"Thank you for using Gentoo. :)",
		"Are you actually trying to read this?",
		"How many times have you stared at this?",
		"We are generating the cache right now",
		"You are paying too much attention.",
		"A theory is better than its explanation.",
		"Phasers locked on target, Captain.",
		"Thrashing is just virtual crashing.",
		"To be is to program.",
		"Real Users hate Real Programmers.",
		"When all else fails, read the instructions.",
		"Functionality breeds Contempt.",
		"The future lies ahead.",
		"3.1415926535897932384626433832795028841971694",
		"Sometimes insanity is the only alternative.",
		"Inaccuracy saves a world of explanation.",
	]

	twirl_sequence = "/-\\|/-\\|/-\\|/-\\|\\-/|\\-/|\\-/|\\-/|"

	def __init__(self):
		self.spinpos = 0
		self.update = self.update_twirl
		self.scroll_sequence = self.scroll_msgs[
			int(time.time() * 100) % len(self.scroll_msgs)]

	def update_basic(self):
		self.spinpos = (self.spinpos + 1) % 500
		if (self.spinpos % 100) == 0:
			if self.spinpos == 0:
				sys.stdout.write(". ")
			else:
				sys.stdout.write(".")
		sys.stdout.flush()

	def update_scroll(self):
		if(self.spinpos >= len(self.scroll_sequence)):
			sys.stdout.write(darkgreen(" \b\b\b" + self.scroll_sequence[
				len(self.scroll_sequence) - 1 - (self.spinpos % len(self.scroll_sequence))]))
		else:
			sys.stdout.write(green("\b " + self.scroll_sequence[self.spinpos]))
		sys.stdout.flush()
		self.spinpos = (self.spinpos + 1) % (2 * len(self.scroll_sequence))

	def update_twirl(self):
		self.spinpos = (self.spinpos + 1) % len(self.twirl_sequence)
		sys.stdout.write("\b\b " + self.twirl_sequence[self.spinpos])
		sys.stdout.flush()

	def update_quiet(self):
		return



def normpath(mystr):
	""" 
		os.path.normpath("//foo") returns "//foo" instead of "/foo"
		We dislike this behavior so we create our own normpath func
		to fix it.
	"""
	if mystr and (mystr[0]=='/'):
		return os.path.normpath("///"+mystr)
	else:
		return os.path.normpath(mystr)

def userquery(prompt, responses=None, colours=None):
	"""Displays a prompt and a set of responses, then waits for a response
	which is checked against the responses and the first to match is
	returned.  An empty response will match the first value in responses.  The
	input buffer is *not* cleared prior to the prompt!

	prompt: a String.
	responses: a List of Strings.
	colours: a List of Functions taking and returning a String, used to
	process the responses for display. Typically these will be functions
	like red() but could be e.g. lambda x: "DisplayString".
	If responses is omitted, defaults to ["Yes", "No"], [green, red].
	If only colours is omitted, defaults to [bold, ...].

	Returns a member of the List responses. (If called without optional
	arguments, returns "Yes" or "No".)
	KeyboardInterrupt is converted to SystemExit to avoid tracebacks being
	printed."""
	if responses is None:
		responses, colours = ["Yes", "No"], [green, red]
	elif colours is None:
		colours=[bold]
	colours=(colours*len(responses))[:len(responses)]
	print bold(prompt),
	try:
		while True:
			response=raw_input("["+string.join([colours[i](responses[i]) for i in range(len(responses))],"/")+"] ")
			for key in responses:
				# An empty response will match the first value in responses.
				if response.upper()==key[:len(response)].upper():
					return key
			print "Sorry, response '%s' not understood." % response,
	except (EOFError, KeyboardInterrupt):
		print "Interrupted."
		sys.exit(1)

def sorted_versions(verlist):
	ret = []
	for ver in verlist:
		verparts = ver.split("-")
		if len(verparts) == 2:
			verrev = int(verparts[1][1:])
		else:
			verrev = 0
		x = 0
		while x < len(ret):
			retparts = ret[x].split("-")
			verdiff = portage.vercmp(retparts[0], verparts[0])
			if verdiff > 0:
				break
			elif verdiff == 0:
				if len(retparts) == 2:
					retrev = int(retparts[1][1:])
				else:
					retrev = 0
				if retrev >= verrev:
					break
			x += 1
		ret.insert(x, ver)
	return ret


actions=[
"clean", "config", "depclean",
"info", "metadata",
"prune", "regen",  "search",
"sync",  "system", "unmerge",  "world",
]
options=[
"--ask",          "--alphabetical",
"--buildpkg",     "--buildpkgonly",
"--changelog",    "--columns", "--cols",
"--debug",        "--deep",
"--digest",
"--emptytree",
"--fetchonly",    "--fetch-all-uri",
"--getbinpkg",    "--getbinpkgonly",
"--help",         "--ignore-default-opts",
"--noconfmem",
"--newuse",       "--nocolor",
"--nodeps",       "--noreplace",
"--nospinner",    "--oneshot",
"--onlydeps",     "--pretend",
"--quiet",        "--resume",
"--searchdesc",   "--selective",
"--skipfirst",    "--skip-first",
"--tree",
"--update",       
"--usepkg",       "--usepkgonly",
"--verbose",      "--version"
]

shortmapping={
"1":"--oneshot",
"a":"--ask",
"b":"--buildpkg",  "B":"--buildpkgonly",
"c":"--clean",     "C":"--unmerge",
"d":"--debug",     "D":"--deep",
"e":"--emptytree",
"f":"--fetchonly", "F":"--fetch-all-uri",
"g":"--getbinpkg", "G":"--getbinpkgonly",
"h":"--help",
"k":"--usepkg",    "K":"--usepkgonly",
"l":"--changelog",
"n":"--noreplace", "N":"--newuse",
"o":"--onlydeps",  "O":"--nodeps",
"p":"--pretend",   "P":"--prune",
"q":"--quiet",
"s":"--search",    "S":"--searchdesc",
't':"--tree",
"u":"--update",
"v":"--verbose",   "V":"--version"
}

def emergelog(xterm_titles, mystr, short_msg=None):
	if xterm_titles:
		if short_msg:
			xtermTitle(short_msg)
		else:
			xtermTitle(mystr)
	try:
		file_path = "/var/log/emerge.log"
		mylogfile = open(file_path, "a")
		portage_util.apply_secpass_permissions(file_path,
			uid=portage.portage_uid, gid=portage.portage_gid,
			mode=0660)

		l=portage_locks.lockfile(mylogfile)
		# seek because we may have gotten held up by the lock.
		# if so, we may not be positioned at the end of the file.
		mylogfile.seek(0,2)
		mylogfile.write(str(time.time())[:10]+": "+mystr+"\n")
		mylogfile.flush()
		portage_locks.unlockfile(l)
		mylogfile.close()
	except (IOError,OSError,portage_exception.PortageException), e:
		if secpass >= 1:
			print >> sys.stderr, "emergelog():",e

def countdown(secs=5, doing="Starting"):
	if secs:
		print ">>> Waiting",secs,"seconds before starting..."
		print ">>> (Control-C to abort)...\n"+doing+" in: ",
		ticks=range(secs)
		ticks.reverse()
		for sec in ticks:
			sys.stdout.write(colorize("UNMERGE_WARN", str(sec+1)+" "))
			sys.stdout.flush()
			time.sleep(1)
		print

# formats a size given in bytes nicely
def format_size(mysize):
	if type(mysize) not in [types.IntType,types.LongType]:
		return str(mysize)
	mystr=str(mysize/1024)
	mycount=len(mystr)
	while (mycount > 3):
		mycount-=3
		mystr=mystr[:mycount]+","+mystr[mycount:]
	return mystr+" kB"


def getgccversion(chost):
	"""
	rtype: C{str}
	return:  the current in-use gcc version
	"""

	gcc_ver_command = 'gcc -dumpversion'
	gcc_ver_prefix = 'gcc-'

	gcc_not_found_error = red(
	"!!! No gcc found. You probably need to 'source /etc/profile'\n" +
	"!!! to update the environment of this terminal and possibly\n" +
	"!!! other terminals also.\n"
	)

	mystatus, myoutput = commands.getstatusoutput("eselect compiler show")
	if mystatus == os.EX_OK and len(myoutput.split("/")) == 2:
		part1, part2 = myoutput.split("/")
		if part1.startswith(chost + "-"):
			return myoutput.replace(chost + "-", gcc_ver_prefix, 1)

	mystatus, myoutput = commands.getstatusoutput("gcc-config -c")
	if mystatus == os.EX_OK and len(myoutput.split("-")) > 0:
		return gcc_ver_prefix + myoutput.split("-")[-1]

	mystatus, myoutput = commands.getstatusoutput(
		chost + "-" + gcc_ver_command)
	if mystatus == os.EX_OK:
		return gcc_ver_prefix + myoutput

	mystatus, myoutput = commands.getstatusoutput(gcc_ver_command)
	if mystatus == os.EX_OK:
		return gcc_ver_prefix + myoutput

	portage.writemsg(gcc_not_found_error, noiselevel=-1)
	return "[unavailable]"

def getportageversion(portdir, target_root, profile, chost, vardb):
	profilever = "unavailable"
	if profile:
		realpath = os.path.realpath(profile)
		basepath   = os.path.realpath(os.path.join(portdir, "profiles"))
		if realpath.startswith(basepath):
			profilever = realpath[1 + len(basepath):]
		else:
			try:
				profilever = "!" + os.readlink(profile)
			except (OSError):
				pass
		del realpath, basepath

	libcver=[]
	libclist  = vardb.match("virtual/libc")
	libclist += vardb.match("virtual/glibc")
	libclist  = portage_util.unique_array(libclist)
	for x in libclist:
		xs=portage.catpkgsplit(x)
		if libcver:
			libcver+=","+string.join(xs[1:], "-")
		else:
			libcver=string.join(xs[1:], "-")
	if libcver==[]:
		libcver="unavailable"

	gccver = getgccversion(chost)
	unameout=os.uname()[2]+" "+os.uname()[4]

	return "Portage " + portage.VERSION +" ("+profilever+", "+gccver+", "+libcver+", "+unameout+")"

def create_depgraph_params(myopts, myaction):
	#configure emerge engine parameters
	#
	# self:      include _this_ package regardless of if it is merged.
	# selective: exclude the package if it is merged
	# recurse:   go into the dependencies
	# deep:      go into the dependencies of already merged packages
	# empty:     pretend nothing is merged
	myparams = ["self", "recurse", "selective"]
	add=[]
	sub=[]
	if "--update" in myopts or myaction in ("system", "world"):
		add.append("empty")
	if "--emptytree" in myopts:
		add.extend(["empty"])
		sub.extend(["selective"])
	if "--nodeps" in myopts:
		sub.extend(["recurse"])
	if "--deep" in myopts:
		add.extend(["deep"])
	elif myaction in ["depclean"]:
		add.extend(["empty"])
		sub.extend(["selective"])
	for x in add:
		if (x not in myparams) and (x not in sub):
			myparams.append(x)
	for x in sub:
		if x in myparams:
			myparams.remove(x)
	return myparams

# search functionality
class search:

	#
	# class constants
	#
	VERSION_SHORT=1
	VERSION_RELEASE=2

	#
	# public interface
	#
	def __init__(self, settings, portdb, vartree, spinner, searchdesc,
		verbose):
		"""Searches the available and installed packages for the supplied search key.
		The list of available and installed packages is created at object instantiation.
		This makes successive searches faster."""
		self.settings = settings
		self.portdb = portdb
		self.vartree = vartree
		self.spinner = spinner
		self.verbose = verbose
		self.searchdesc = searchdesc

	def execute(self,searchkey):
		"""Performs the search for the supplied search key"""
		match_category = 0
		self.searchkey=searchkey
		self.packagematches = []
		if self.searchdesc:
			self.searchdesc=1
			self.matches = {"pkg":[], "desc":[]}
		else:
			self.searchdesc=0
			self.matches = {"pkg":[]}
		print "Searching...   ",

		regexsearch = False
		if self.searchkey[0] == '%':
			regexsearch = True
			self.searchkey = self.searchkey[1:]
		if self.searchkey[0] == '@':
			match_category = 1
			self.searchkey = self.searchkey[1:]
		if regexsearch:
			self.searchre=re.compile(self.searchkey,re.I)
		else:
			self.searchre=re.compile(re.escape(self.searchkey), re.I)
		for package in self.portdb.cp_all():
			self.spinner.update()

			if match_category:
				match_string  = package[:]
			else:
				match_string  = package.split("/")[-1]

			masked=0
			if self.searchre.search(match_string):
				if not self.portdb.xmatch("match-visible", package):
					masked=1
				self.matches["pkg"].append([package,masked])
			elif self.searchdesc: # DESCRIPTION searching
				full_package = self.portdb.xmatch("bestmatch-visible", package)
				if not full_package:
					#no match found; we don't want to query description
					full_package = portage.best(
						self.portdb.xmatch("match-all", package))
					if not full_package:
						continue
					else:
						masked=1
				try:
					full_desc = self.portdb.aux_get(
						full_package, ["DESCRIPTION"])[0]
				except KeyError:
					print "emerge: search: aux_get() failed, skipping"
					continue
				if self.searchre.search(full_desc):
					self.matches["desc"].append([full_package,masked])
		self.mlen=0
		for mtype in self.matches.keys():
			self.matches[mtype].sort()
			self.mlen += len(self.matches[mtype])

	def output(self):
		"""Outputs the results of the search."""
		print "\b\b  \n[ Results for search key : "+white(self.searchkey)+" ]"
		print "[ Applications found : "+white(str(self.mlen))+" ]"
		print " "
		for mtype in self.matches.keys():
			for match,masked in self.matches[mtype]:
				if mtype=="pkg":
					catpack=match
					full_package = self.portdb.xmatch(
						"bestmatch-visible", match)
					if not full_package:
						#no match found; we don't want to query description
						masked=1
						full_package = portage.best(
							self.portdb.xmatch("match-all",match))
				else:
					full_package = match
					match        = portage.pkgsplit(match)[0]

				if full_package:
					try:
						desc, homepage, license = self.portdb.aux_get(
							full_package, ["DESCRIPTION","HOMEPAGE","LICENSE"])
					except KeyError:
						print "emerge: search: aux_get() failed, skipping"
						continue
					if masked:
						print green("*")+"  "+white(match)+" "+red("[ Masked ]")
					else:
						print green("*")+"  "+white(match)
					myversion = self.getVersion(full_package, search.VERSION_RELEASE)

					mysum = [0,0]
					mycat = match.split("/")[0]
					mypkg = match.split("/")[1]
					mycpv = match + "-" + myversion
					myebuild = self.portdb.findname(mycpv)
					pkgdir = os.path.dirname(myebuild)
					import portage_manifest
					mf = portage_manifest.Manifest(
						pkgdir, self.settings["DISTDIR"])
					fetchlist = self.portdb.getfetchlist(mycpv,
						mysettings=self.settings, all=True)[1]
					try:
						mysum[0] = mf.getDistfilesSize(fetchlist)
						mystr = str(mysum[0]/1024)
						mycount=len(mystr)
						while (mycount > 3):
							mycount-=3
							mystr=mystr[:mycount]+","+mystr[mycount:]
						mysum[0]=mystr+" kB"
					except KeyError, e:
						mysum[0] = "Unknown (missing digest for %s)" % str(e)

					if self.verbose:
						print "     ", darkgreen("Latest version available:"),myversion
						print "     ", self.getInstallationStatus(mycat+'/'+mypkg)
						print "     ", darkgreen("Size of files:"),mysum[0]
						print "     ", darkgreen("Homepage:")+"     ",homepage
						print "     ", darkgreen("Description:")+"  ",desc
						print "     ", darkgreen("License:")+"      ",license
						print
		print
	#
	# private interface
	#
	def getInstallationStatus(self,package):
		installed_package = self.vartree.dep_bestmatch(package)
		result = ""
		version = self.getVersion(installed_package,search.VERSION_RELEASE)
		if len(version) > 0:
			result = darkgreen("Latest version installed:")+" "+version
		else:
			result = darkgreen("Latest version installed:")+" [ Not Installed ]"
		return result

	def getVersion(self,full_package,detail):
		if len(full_package) > 1:
			package_parts = portage.catpkgsplit(full_package)
			if detail == search.VERSION_RELEASE and package_parts[3] != 'r0':
				result = package_parts[2]+ "-" + package_parts[3]
			else:
				result = package_parts[2]
		else:
			result = ""
		return result


#build our package digraph
def getlist(settings, mode):
	if mode=="system":
		mylines = settings.packages
	elif mode=="world":
		try:
			file_path = os.path.join(settings["ROOT"], portage.WORLD_FILE)
			myfile = open(file_path, "r")
			mylines = myfile.readlines()
			myfile.close()
		except (OSError, IOError), e:
			if e.errno == errno.ENOENT:
				portage.writemsg("\n!!! World file does not exist: '%s'\n" % file_path)
				mylines=[]
			else:
				raise
	mynewlines=[]
	for x in mylines:
		myline=string.join(string.split(x))
		if not len(myline):
			continue
		elif myline[0]=="#":
			continue
		elif mode=="system":
			if myline[0]!="*":
				continue
			myline=myline[1:]
		mynewlines.append(myline.strip())

	# Remove everything that is package.provided from our list
	for atom in mynewlines[:]:
		for expanded_atom in portage.flatten(
			portage.dep_virtual([atom], settings)):
			mykey = portage.dep_getkey(expanded_atom)
			if mykey in settings.pprovideddict and \
				portage.match_from_list(
					expanded_atom, settings.pprovideddict[mykey]):
					mynewlines.remove(atom)
					break

	return mynewlines

def clean_world(vardb, cpv):
	"""Remove a package from the world file when unmerged."""
	world_filename = os.path.join(vardb.root, portage.WORLD_FILE)
	worldlist = portage_util.grabfile(world_filename)
	mykey = portage.cpv_getkey(cpv)
	newworldlist = []
	for x in worldlist:
		if portage.dep_getkey(x) == mykey:
			matches = vardb.match(x, use_cache=0)
			if not matches:
				#zap our world entry
				pass
			elif len(matches) == 1 and matches[0] == cpv:
				#zap our world entry
				pass
			else:
				#others are around; keep it.
				newworldlist.append(x)
		else:
			#this doesn't match the package we're unmerging; keep it.
			newworldlist.append(x)

	portage_util.ensure_dirs(os.path.join(vardb.root, portage.PRIVATE_PATH),
		gid=portage.portage_gid, mode=02770)
	portage_util.write_atomic(world_filename, "\n".join(newworldlist))

def genericdict(mylist):
	mynewdict={}
	for x in mylist:
		mynewdict[portage.dep_getkey(x)]=x
	return mynewdict

class depgraph:

	pkg_tree_map = {
		"ebuild":"porttree",
		"binary":"bintree",
		"installed":"vartree"}

	def __init__(self, settings, trees, myopts, myparams, spinner):
		self.settings = settings
		self.target_root = settings["ROOT"]
		self.trees = trees
		self.myopts = myopts
		self.myparams = myparams
		self.edebug = 0
		if settings.get("PORTAGE_DEBUG", "") == "1":
			self.edebug = 1
		self.spinner = spinner
		self.pkgsettings = {}
		self.pkgsettings[self.target_root] = portage.config(clone=settings)
		if self.target_root != "/":
			self.pkgsettings["/"] = \
				portage.config(clone=trees["/"]["vartree"].settings)
		self.useFlags = {}
		self.useFlags[self.target_root] = {}
		if self.target_root != "/":
			self.useFlags["/"] = {}

		self.missingbins=[]
		self.digraph=portage.digraph()
		self.orderedkeys=[]
		self.outdatedpackages=[]
		self.mydbapi={}
		self.mydbapi["/"] = portage.fakedbapi(settings=settings)
		self.pkg_slots={"/" : {}}
		allcpv = self.trees["/"]["vartree"].getallcpv()
		if "empty" not in self.myparams or self.target_root != "/":
			for pkg in allcpv:
				self.mydbapi["/"].cpv_inject(pkg)
		for pkg in allcpv:
			myslot = self.trees["/"]["vartree"].dbapi.aux_get(pkg, ["SLOT"])[0]
			mykey = portage.dep_getkey(pkg)
			if mykey in self.pkg_slots["/"]:
				self.pkg_slots["/"][mykey][myslot] = pkg
			else:
				self.pkg_slots["/"][mykey] = {myslot:pkg}
		if self.target_root != "/":
			self.pkg_slots[self.target_root] = {}
			allcpv = self.trees[self.target_root]["vartree"].getallcpv()
			self.mydbapi[self.target_root] = \
				portage.fakedbapi(settings=settings)
			if "empty" not in self.myparams:
				for pkg in allcpv:
					self.mydbapi[self.target_root].cpv_inject(pkg)
			for pkg in allcpv:
				myslot = self.trees[self.target_root]["vartree"].dbapi.aux_get(
					pkg, ["SLOT"])[0]
				mykey = portage.dep_getkey(pkg)
				if mykey in self.pkg_slots[self.target_root]:
					self.pkg_slots[self.target_root][mykey][myslot] = pkg
				else:
					self.pkg_slots[self.target_root][mykey] = {myslot:pkg}
		if "--usepkg" in self.myopts:
			trees["/"]["bintree"].populate(
				"--getbinpkg" in self.myopts, "--getbinpkgonly" in self.myopts)
			if self.target_root != "/":
				trees[self.target_root]["bintree"].populate(
					"--getbinpkg" in self.myopts,
					"--getbinpkgonly" in self.myopts)

	def create(self, mybigkey, myparent=None, addme=1, myuse=None,
		soft_dep=False, rev_dep=False, arg=None):
		"""
		Fills the digraph with nodes comprised of packages to merge.
		mybigkey is the package spec of the package to merge.
		myparent is the package depending on mybigkey ( or None )
		addme = Should we add this package to the digraph or are we just looking at it's deps?
			Think --onlydeps, we need to ignore packages in that case.
		#stuff to add:
		#SLOT-aware emerge
		#IUSE-aware emerge -> USE DEP aware depgraph
		#"no downgrade" emerge
		"""

		jbigkey = " ".join(mybigkey) + " merge"
		if self.digraph.hasnode(jbigkey):
			if addme and jbigkey != myparent:
				# Refuse to make a node depend on itself so that the we don't
				# don't create a bogus circular dependency in self.altlist().
				if rev_dep and myparent:
					self.digraph.addnode(myparent, jbigkey, soft_dep=soft_dep)
				else:
					self.digraph.addnode(jbigkey, myparent, soft_dep=soft_dep)
			return 1
		jbigkey = " ".join(mybigkey) + " nomerge"
		if self.digraph.hasnode(jbigkey):
			if rev_dep and myparent:
				self.digraph.addnode(myparent, jbigkey, soft_dep=soft_dep)
			else:
				self.digraph.addnode(jbigkey, myparent, soft_dep=soft_dep)
			if arg:
				self.digraph.replace(jbigkey, " ".join(mybigkey) + " merge")
			return 1
		
		self.spinner.update()
		mytype,myroot,mykey=mybigkey
		# select the correct /var database that we'll be checking against
		vardbapi = self.trees[myroot]["vartree"].dbapi
		portdb = self.trees[myroot]["porttree"].dbapi
		bindb = self.trees[myroot]["bintree"].dbapi
		pkgsettings = self.pkgsettings[myroot]

		# if the package is already on the system, we add a "nomerge"
		# directive, otherwise we add a "merge" directive.
		
		if mytype=="blocks":
			""" We ignore blocks unless the package that is blocked is installed
			    We need to check vardbapi as well as the current depgraph for it.
			    Blocks are fatal if buildpkgonly is set. """
			if addme and "--buildpkgonly" not in self.myopts and myparent:
				mybigkey[1] = myparent.split()[1]
				self.digraph.addnode(" ".join(mybigkey), myparent,
					soft_dep=soft_dep)
			return 1
		else:
			mydbapi = self.trees[myroot][self.pkg_tree_map[mytype]].dbapi
			if addme:
				myslot = mydbapi.aux_get(mykey, ["SLOT"])[0]
				depkey = portage.dep_getkey(mykey)
				if depkey in self.pkg_slots:
					self.pkg_slots[myroot][depkey][myslot] = mykey
				else:
					self.pkg_slots[myroot][depkey] = {myslot : mykey}

		if myuse is None:
			self.pkgsettings[myroot].setcpv(mykey)
			myuse = self.pkgsettings[myroot]["USE"].split()
		self.useFlags[myroot][mykey] = myuse

		merging=1
		if addme:
		# this is where we add the node to the list of packages to merge
			if not myparent:
				""" If there is no parent, the package was specified on the
				    command line or is part of system/world sets.
				    In either case, if we aren't in 'self' mode (where package
				    is always included and if in 'selective' mode package is already
				    installed we skip merging it."""
				if "self" not in self.myparams or \
					("selective" in self.myparams and \
					not arg and vardbapi.cpv_exists(mykey)):
					merging=0
			elif "selective" in self.myparams and vardbapi.cpv_exists(mykey):
				merging=0

			""" If we aren't merging, perform the --newuse check.
			    If the package has new iuse flags or different use flags then if
			    --newuse is specified, we need to merge the package. """
			if merging==0 and "--newuse" in self.myopts and \
				vardbapi.cpv_exists(mykey):
				pkgsettings.setcpv(mykey)
				forced_flags = set()
				forced_flags.update(pkgsettings.useforce)
				forced_flags.update(pkgsettings.puseforce)
				forced_flags.update(pkgsettings.usemask)
				forced_flags.update(pkgsettings.pusemask)
				old_use = vardbapi.aux_get(mykey, ["USE"])[0].split()
				iuses = set(mydbapi.aux_get(mykey, ["IUSE"])[0].split())
				old_iuse = set(vardbapi.aux_get(mykey, ["IUSE"])[0].split())
				if iuses.symmetric_difference(
					old_iuse).difference(forced_flags):
					merging = 1
				elif old_iuse.intersection(old_use) != \
					iuses.intersection(myuse):
					merging=1

		if addme and merging == 1:
			mybigkey.append("merge")
		else:
			mybigkey.append("nomerge")

		if merging == 0 and vardbapi.cpv_exists(mykey):
			myuse = vardbapi.aux_get(mykey, ["USE"])[0].split()
			self.useFlags[myroot][mykey] = myuse

		""" At this point, we have either hit a blocker and returned, found the package in the
		    depgraph already and returned, or we are here.  Whether we are merging or not; we must
		    add the package to the depgraph; so we do that here. """
		if rev_dep and myparent:
			self.digraph.addnode(myparent, " ".join(mybigkey),
				soft_dep=soft_dep)
		else:
			self.digraph.addnode(" ".join(mybigkey), myparent,
				soft_dep=soft_dep)
		
		""" This section determines whether we go deeper into dependencies or not.
		    We want to go deeper on a few occasions:
		    Installing package A, we need to make sure package A's deps are met.
		    emerge --deep <pkgspec>; we need to recursively check dependencies of pkgspec
		    If we are in --nodeps (no recursion) mode, we obviously only check 1 level of dependencies.
		"""
		if "deep" not in self.myparams and not merging:
			return 1
		elif "recurse" not in self.myparams:
			return 1

		""" Check DEPEND/RDEPEND/PDEPEND/SLOT
		Pull from bintree if it's binary package, porttree if it's ebuild.
		Binpkg's can be either remote or local. """

		edepend={}
		depkeys = ["DEPEND","RDEPEND","PDEPEND"]
		depvalues = mydbapi.aux_get(mykey, depkeys)
		for i in xrange(len(depkeys)):
			edepend[depkeys[i]] = depvalues[i]

		if mytype == "binary":
			edepend["DEPEND"] = ""
		elif mytype == "ebuild":
			if "--buildpkgonly" in self.myopts:
				edepend["RDEPEND"] = ""
				edepend["PDEPEND"] = ""

		""" We have retrieve the dependency information, now we need to recursively
		    process them.  DEPEND gets processed for root = "/", {R,P}DEPEND in myroot. """
		
		mp=string.join(mybigkey)

		try:
			if not self.select_dep("/", edepend["DEPEND"], myparent=mp,
				myuse=myuse):
				return 0
			if not self.select_dep(myroot,edepend["RDEPEND"], myparent=mp,
				myuse=myuse, soft_deps=True):
				return 0
			if edepend.has_key("PDEPEND") and edepend["PDEPEND"]:
				# Post Depend -- Add to the list without a parent, as it depends
				# on a package being present AND must be built after that package.
				if not self.select_dep(myroot, edepend["PDEPEND"], myparent=mp,
					myuse=myuse, soft_deps=True, rev_deps=True):
					return 0
		except ValueError, e:
			pkgs = e.args[0]
			portage.writemsg("\n\n!!! An atom in the dependencies " + \
				"is not fully-qualified. Multiple matches:\n\n", noiselevel=-1)
			for cpv in pkgs:
				portage.writemsg("    %s\n" % cpv, noiselevel=-1)
			portage.writemsg("\n", noiselevel=-1)
			if mytype == "binary":
				portage.writemsg(
					"!!! This binary package cannot be installed: '%s'\n" % \
					mykey, noiselevel=-1)
			elif mytype == "ebuild":
				myebuild, mylocation = portdb.findname2(mykey)
				portage.writemsg("!!! This ebuild cannot be installed: " + \
					"'%s'\n" % myebuild, noiselevel=-1)
			portage.writemsg("!!! Please notify the package maintainer " + \
				"that atoms must be fully-qualified.\n", noiselevel=-1)
			return 0
		return 1

	def select_files(self,myfiles):
		"given a list of .tbz2s, .ebuilds and deps, create the appropriate depgraph and return a favorite list"
		myfavorites=[]
		myroot = self.target_root
		portdb = self.trees[myroot]["porttree"].dbapi
		pkgsettings = self.pkgsettings[myroot]
		for x in myfiles:
			ext = os.path.splitext(x)[1]
			if ext==".tbz2":
				if not os.path.exists(x):
					if os.path.exists(
						os.path.join(pkgsettings["PKGDIR"], "All", x)):
						x = os.path.join(pkgsettings["PKGDIR"], "All", x)
					elif os.path.exists(
						os.path.join(pkgsettings["PKGDIR"], x)):
						x = os.path.join(pkgsettings["PKGDIR"], x)
					else:
						print "\n\n!!! Binary package '"+str(x)+"' does not exist."
						print "!!! Please ensure the tbz2 exists as specified.\n"
						sys.exit(1)
				mytbz2=xpak.tbz2(x)
				mykey=mytbz2.getelements("CATEGORY")[0]+"/"+os.path.splitext(os.path.basename(x))[0]
				if os.path.realpath(x) != \
					os.path.realpath(self.trees[myroot]["bintree"].getname(mykey)):
					print colorize("BAD", "\n*** You need to adjust PKGDIR to emerge this package.\n")
					sys.exit(1)
				if not self.create(["binary", myroot, mykey],
					None, "--onlydeps" not in self.myopts):
					return (0,myfavorites)
				elif not "--oneshot" in self.myopts:
					myfavorites.append(mykey)
			elif ext==".ebuild":
				x = os.path.realpath(x)
				mykey=os.path.basename(os.path.normpath(x+"/../.."))+"/"+os.path.splitext(os.path.basename(x))[0]
				ebuild_path = portdb.findname(mykey)
				if ebuild_path:
					if os.path.realpath(ebuild_path) != x:
						print colorize("BAD", "\n*** You need to adjust PORTDIR or PORTDIR_OVERLAY to emerge this package.\n")
						sys.exit(1)
					if mykey not in portdb.xmatch(
						"match-visible", portage.dep_getkey(mykey)):
						print colorize("BAD", "\n*** You are emerging a masked package. It is MUCH better to use")
						print colorize("BAD", "*** /etc/portage/package.* to accomplish this. See portage(5) man")
						print colorize("BAD", "*** page for details.")
						countdown(int(self.settings["EMERGE_WARNING_DELAY"]),
							"Continuing...")
				else:
					raise portage_exception.PackageNotFound(
						"%s is not in a valid portage tree hierarchy or does not exist" % x)
				if not self.create(["ebuild", myroot, mykey],
					None, "--onlydeps" not in self.myopts):
					return (0,myfavorites)
				elif not "--oneshot" in self.myopts:
					myfavorites.append(mykey)
			else:
				if not is_valid_package_atom(x):
					portage.writemsg("\n\n!!! '%s' is not a valid package atom.\n" % x,
						noiselevel=-1)
					portage.writemsg("!!! Please check ebuild(5) for full details.\n")
					portage.writemsg("!!! (Did you specify a version but forget to prefix with '='?)\n")
					return (0,[])
				try:
					mykey = portage.dep_expand(x,
						mydb=portdb, settings=pkgsettings)
					if mykey.startswith("null/"):
						# If category expansion fails against the portage tree,
						# remove the null/ prefix so that it may be given
						# another chance to expand against the binary package
						# tree in select_dep().
						mykey = mykey[5:]
				except ValueError, errpkgs:
					print "\n\n!!! The short ebuild name \"" + x + "\" is ambiguous.  Please specify"
					print "!!! one of the following fully-qualified ebuild names instead:\n"
					for i in errpkgs[0]:
						print "    " + green(i)
					print
					sys.exit(1)

				# select needs to return 0 on dep_check failure

				sys.stdout.flush()
				sys.stderr.flush()

				try:
					if "--noreplace" in self.myopts:
						arg = None
					else:
						arg = x
					self.mysd = self.select_dep(myroot, mykey, arg=arg)
				except portage_exception.MissingSignature, e:
					portage.writemsg("\n\n!!! A missing gpg signature is preventing portage from calculating the\n")
					portage.writemsg("!!! required dependencies. This is a security feature enabled by the admin\n")
					portage.writemsg("!!! to aid in the detection of malicious intent.\n\n")
					portage.writemsg("!!! THIS IS A POSSIBLE INDICATION OF TAMPERED FILES -- CHECK CAREFULLY.\n")
					portage.writemsg("!!! Affected file: %s\n" % (e), noiselevel=-1)
					sys.exit(1)
				except portage_exception.InvalidSignature, e:
					portage.writemsg("\n\n!!! An invalid gpg signature is preventing portage from calculating the\n")
					portage.writemsg("!!! required dependencies. This is a security feature enabled by the admin\n")
					portage.writemsg("!!! to aid in the detection of malicious intent.\n\n")
					portage.writemsg("!!! THIS IS A POSSIBLE INDICATION OF TAMPERED FILES -- CHECK CAREFULLY.\n")
					portage.writemsg("!!! Affected file: %s\n" % (e), noiselevel=-1)
					sys.exit(1)
				except SystemExit, e:
					raise # Needed else can't exit
				except Exception, e:
					print >> sys.stderr, "\n\n!!! Problem in '%s' dependencies." % mykey
					print >> sys.stderr, "!!!", str(e), e.__module__
					raise

				if not self.mysd:
					return (0,myfavorites)
				elif not "--oneshot" in self.myopts:
					myfavorites.append(portage.dep_getkey(mykey))

		missing=0
		if "--usepkgonly" in self.myopts:
			for x in self.digraph.all_nodes():
				xs = x.split()
				if len(xs) >= 4 and xs[0] != "binary" and xs[3] == "merge":
					if missing == 0:
						print
					missing += 1
					print "Missing binary for:",xs[2]

		self.validate_blockers()
		
		# We're true here unless we are missing binaries.
		return (not missing,myfavorites)

	def is_newer_ver_installed(self,myroot,pkg,pkgver):
		"if there is a version of pkg installed newer than pkgver, return it"
		vardbapi = self.trees[myroot]["vartree"].dbapi

		matches = self.trees[myroot]["vartree"].dbapi.match(pkg)
		if matches:
			myslot = self.trees[myroot]["porttree"].getslot(pkgver)
			for match in matches:
				if portage.pkgcmp(portage.catpkgsplit(pkgver)[1:], portage.catpkgsplit(match)[1:]) < 0:
					curslot = self.trees[myroot]["vartree"].getslot(match)
					if curslot == myslot:
						return match

	def select_dep(self, myroot, depstring, myparent=None, arg=None,
		myuse=None, raise_on_missing=False, soft_deps=False, rev_deps=False):
		""" Given a depstring, create the depgraph such that all dependencies are satisfied.
		    myroot = $ROOT from environment, where {R,P}DEPENDs are merged to.
		    myparent = the node whose depstring is being passed in
		    arg = package was specified on the command line, merge even if it's already installed
		    myuse = USE flags at present
		    raise_on_missing = Given that the depgraph is not proper, raise an exception if true
		    else continue trying.
		    return 1 on success, 0 for failure
		"""

		portdb = self.trees[myroot]["porttree"].dbapi
		bindb  = self.trees[myroot]["bintree"].dbapi
		vardb  = self.trees[myroot]["vartree"].dbapi
		pkgsettings = self.pkgsettings[myroot]

		if "--debug" in self.myopts:
			print
			print "Parent:   ",myparent
			print "Depstring:",depstring
			if rev_deps:
				print "Reverse:", rev_deps
			if soft_deps:
				print "Soft:", soft_deps
		
		if not arg:
			#processing dependencies
			""" Call portage.dep_check to evaluate the use? conditionals and make sure all
			dependencies are satisfiable. """
			mycheck = portage.dep_check(depstring, self.mydbapi[myroot],
				pkgsettings, myuse=myuse,
				use_binaries=("--usepkgonly" in self.myopts),
				myroot=myroot, trees=self.trees, return_all_deps=True)

			if not mycheck[0]:
				mymerge=[]
			else:
				mymerge=mycheck[1]

		else:
			#we're processing a command-line argument; unconditionally merge it even if it's already merged
			mymerge=[depstring]

		if myparent:
			# In order to get past circular dependencies (in
			# `emerge -e world`, for example), the parent must be allowed
			# to satisfy dependencies of it's children.

			# The parent is added after it's own dep_check call so that it
			# isn't allowed to satisfy a direct bootstrap dependency on itself
			# or an old-style virtual that it satisfies (unfortunately, this
			# only works for one level of deps, so it won't work for new-style
			# virtuals since they introduce an additional level of dependency
			# indirection).

			p_type, p_root, p_key, p_status = myparent.split()
			if p_status == "merge":
				""" This fakedbapi data is used in dep_check calls to determine
				satisfied deps via dep_wordreduce"""
				self.mydbapi[p_root].cpv_inject(p_key)

				# Update old-style virtuals if this package provides any.
				# These are needed for dep_virtual calls inside dep_check.
				self.pkgsettings[p_root].setinst(p_key,
					self.trees[p_root][self.pkg_tree_map[p_type]].dbapi)

		if "--debug" in self.myopts:
			print "Candidates:",mymerge
		for x in mymerge:
			selected_pkg = None
			if x[0]=="!":
				# if this package is myself, don't append it to block list.
				if "--debug" in self.myopts:
					print "Myparent",myparent
				if (myparent):
					if myparent.split()[2] in \
						portdb.xmatch("match-all", x[1:]):
						# myself, so exit.
						continue
				# adding block
				selected_pkg = ["blocks", myroot, x[1:], None]
			else:
				#We are not processing a blocker but a normal dependency
				if not arg:
					if "empty" not in self.myparams and \
						"deep" not in self.myparams and \
						vardb.match(x):
						continue

					pkg_key = portage.dep_getkey(x)
					if pkg_key in pkgsettings.pprovideddict and \
						portage.match_from_list(
							x, pkgsettings.pprovideddict[pkg_key]):
							continue

				# List of acceptable packages, ordered by type preference.
				matched_packages = []
				myeb_matches = portdb.xmatch("match-visible", x)
				myeb = None
				if "--usepkgonly" not in self.myopts:
					myeb = portage.best(myeb_matches)

				myeb_pkg=None
				if "--usepkg" in self.myopts:
					# The next line assumes the binarytree has been populated.
					# XXX: Need to work out how we use the binary tree with roots.
					myeb_pkg_matches = bindb.match(x)
					if "--usepkgonly" not in self.myopts:
						# Remove any binary package entries that are masked in the portage tree (#55871)
						myeb_pkg_matches = [pkg for pkg in myeb_pkg_matches \
							if pkg in myeb_matches or  \
							not portdb.cpv_exists(pkg)]
					if myeb_pkg_matches:
						myeb_pkg = portage.best(myeb_pkg_matches)

				if myeb_pkg and "--newuse" in self.myopts:
					iuses = set(bindb.aux_get(myeb_pkg, ["IUSE"])[0].split())
					old_use = bindb.aux_get(myeb_pkg, ["USE"])[0].split()
					pkgsettings.setcpv(myeb_pkg)
					now_use = pkgsettings["USE"].split()
					forced_flags = set()
					forced_flags.update(pkgsettings.useforce)
					forced_flags.update(pkgsettings.puseforce)
					forced_flags.update(pkgsettings.usemask)
					forced_flags.update(pkgsettings.pusemask)
					cur_iuse = iuses
					if "--usepkgonly" not in self.myopts and myeb:
						cur_iuse = set(portdb.aux_get(myeb, ["IUSE"])[0].split())
					if iuses.symmetric_difference(
						cur_iuse).difference(forced_flags):
						myeb_pkg = None
					elif iuses.intersection(old_use) != \
						cur_iuse.intersection(now_use):
						myeb_pkg = None
				if myeb_pkg:
					binpkguseflags = \
						self.trees[myroot]["bintree"].dbapi.aux_get(
							myeb_pkg, ["USE"])[0].split()
					matched_packages.append(
						["binary", myroot, myeb_pkg, binpkguseflags])

				if "--usepkgonly" not in self.myopts and myeb_matches:
					matched_packages.append(
						["ebuild", myroot, myeb, None])

				if not matched_packages:
					if raise_on_missing:
						raise ValueError
					if not arg:
						xinfo='"'+x+'"'
					else:
						xinfo='"'+arg+'"'
					if myparent:
						xfrom = '(dependency required by '+green('"'+myparent.split()[2]+'"')+red(' ['+myparent.split()[0]+"]")+')'
					alleb = portdb.xmatch("match-all", x)
					if alleb:
						if "--usepkgonly" not in self.myopts:
							print "\n!!! "+red("All ebuilds that could satisfy ")+green(xinfo)+red(" have been masked.")
							print "!!! One of the following masked packages is required to complete your request:"
							oldcomment = ""
							for p in alleb:
								mreasons = portage.getmaskingstatus(p,
									settings=pkgsettings, portdb=portdb)
								print "- "+p+" (masked by: "+string.join(mreasons, ", ")+")"
								comment = portage.getmaskingreason(p,
									settings=pkgsettings, portdb=portdb)
								if comment and comment != oldcomment:
									print comment
									oldcomment = comment
							print
							print "For more information, see MASKED PACKAGES section in the emerge man page or "
							print "refer to the Gentoo Handbook."
						else:
							print "\n!!! "+red("There are no packages available to satisfy: ")+green(xinfo)
							print "!!! Either add a suitable binary package or compile from an ebuild."
					else:
						print "\nemerge: there are no ebuilds to satisfy "+green(xinfo)+"."
					if myparent:
						print xfrom
					print
					return 0

				if "--debug" in self.myopts:
					for pkg in matched_packages:
						print (pkg[0] + ":").rjust(10), pkg[2]

				if len(matched_packages) > 1:
					bestmatch = portage.best(
						[pkg[2] for pkg in matched_packages])
					matched_packages = [pkg for pkg in matched_packages \
						if pkg[2] == bestmatch]

				# ordered by type preference ("ebuild" type is the last resort)
				selected_pkg =  matched_packages[0]

			if myparent:
				#we are a dependency, so we want to be unconditionally added
				soft_dep = soft_deps or vardb.match(x)
				if not self.create(selected_pkg[0:3], myparent,
					myuse=selected_pkg[-1], soft_dep=soft_dep,
					rev_dep=rev_deps, arg=arg):
					return 0
			else:
				#if mysource is not set, then we are a command-line dependency and should not be added
				#if --onlydeps is specified.
				if not self.create(selected_pkg[0:3], myparent,
					addme=("--onlydeps" not in self.myopts),
					myuse=selected_pkg[-1], rev_dep=rev_deps, arg=arg):
					return 0

		if "--debug" in self.myopts:
			print "Exiting...",myparent
		return 1

	def validate_blockers(self):
		"""Remove any blockers from the digraph that do not match any of the
		packages within the graph.  Blockers are only matched against the
		final state of the graph.  Thus, it's possible that mutually blocking
		packages will be installed simultaneously a some point(s) during the
		transition from the initial to the final state."""
		all_blockers = [node for node in self.digraph.all_nodes()
				if node.split()[0] == "blocks"]
		for blocker in all_blockers:
			mytype, myroot, mydep = blocker.split()
			"""Prior to being added to the digraph, any blockers against
			old-style virtuals have been expanded to real packages via
			dep_virtual calls inside dep_check."""
			mykey = portage.dep_getkey(mydep)
			valid = False
			pkgs = self.pkg_slots[myroot].get(mykey, None)
			if pkgs and portage.match_from_list(mydep,
				[pkgs[myslot] for myslot in pkgs]):
				valid = True
			if not valid:
				self.digraph.remove(blocker)

	def altlist(self, reversed=False):
		mygraph=self.digraph.copy()
		retlist=[]
		while not mygraph.empty():
			if reversed:
				nodes = mygraph.root_nodes()
				if not nodes:
					nodes = mygraph.root_nodes(ignore_soft_deps=True)
				if nodes:
					next_node = nodes[-1]
				else:
					next_node = None
			else:
				nodes = mygraph.leaf_nodes()
				if not nodes:
					nodes = mygraph.leaf_nodes(ignore_soft_deps=True)
				if nodes:
					next_node = nodes[0]
				else:
					next_node = None
			if not next_node:
				print "!!! Error: circular dependencies:"
				print
				mygraph.debug_print()
				sys.exit(1)
			retlist.append(next_node.split())
			mygraph.remove(next_node)
		return retlist

	def xcreate(self,mode="system"):
		world_problems = False
		if mode=="system":
			mylist = getlist(self.settings, "system")
		else:
			#world mode
			worldlist = getlist(self.settings, "world")
			sysdict = genericdict(getlist(self.settings, "system"))
			worlddict=genericdict(worldlist)

			for x in worlddict.keys():
				if not portage.isvalidatom(x):
					world_problems = True
				elif not self.trees[self.target_root]["vartree"].dbapi.match(x):
					world_problems = True
				else:
					sysdict[x]=worlddict[x]

			mylist = sysdict.keys()

		newlist = []
		for atom in mylist:
			if portage.dep_getkey(atom).split("/")[-1] == "portage":
				newlist.insert(0, atom)
			else:
				newlist.append(atom)
		mylist = newlist
		
		missing_atoms = []
		for mydep in mylist:
			try:
				if not self.select_dep(
					self.target_root, mydep, raise_on_missing=True):
					print "\n\n!!! Problem resolving dependencies for", mydep
					return 0
			except ValueError:
				missing_atoms.append(mydep)

		self.validate_blockers()

		if world_problems:
			print "\n!!! Problems have been detected with your world file"
			print "!!! Please run "+green("emaint --check world")+"\n"

		if missing_atoms:
			print "\n" + colorize("BAD", "!!!") + \
				" Ebuilds for the following packages are either all"
			print colorize("BAD", "!!!") + " masked or don't exist:"
			print " ".join(missing_atoms) + "\n"

		return 1

	def match(self, mydep, myroot=None, mykey=None):
		# support mutual exclusive deps
		if myroot is None:
			myroot = self.target_root
		mydep2=mydep
		if mydep2[0]=="!":
			mydep2=mydep[1:]

		if mydep[0]=="!":
			#add our blocker; it will be ignored later if necessary (if we are remerging the same pkg, for example)
			myk="blocks "+myroot+" "+mydep2
		else:
			myeb = self.trees[myroot]["porttree"].dep_bestmatch(mydep2)
			if not myeb:
				if not mykey:
					print "\n!!! Error: couldn't find match for",mydep
				else:
					print "\n!!! Error: couldn't find match for",mydep,"in",mykey
				print
				sys.exit(1)

			if "--usepkg" in self.myopts:
				mypk = self.trees[myroot]["bintree"].dep_bestmatch(mydep)
				if myeb==mypk:
					myk = " ".join(("binary", myroot, mypk))
				else:
					myk = " ".join(("ebuild", myroot, myeb))
			else:
				myk="ebuild "+myroot+" "+myeb

		return myk

	def display(self,mylist,verbosity=None):
		if verbosity is None:
			verbosity = ("--quiet" in self.myopts and 1 or \
				"--verbose" in self.myopts and 3 or 2)
		changelogs=[]
		p=[]
		totalsize=0

		if verbosity == 1 and "--verbose" not in self.myopts:
			def create_use_string(*args):
				return ""
		else:
			def create_use_string(name, cur_iuse, iuse_forced, cur_use,
				old_iuse, old_use,
				is_new, all_flags=(verbosity == 3 or "--quiet" in self.myopts),
				alphabetical=("--alphabetical" in self.myopts)):
				enabled = []
				if alphabetical:
					disabled = enabled
					removed = enabled
				else:
					disabled = []
					removed = []
				cur_iuse = set(cur_iuse)
				enabled_flags = cur_iuse.intersection(cur_use)
				removed_iuse = set(old_iuse).difference(cur_iuse)
				any_iuse = cur_iuse.union(old_iuse)
				any_iuse = list(any_iuse)
				any_iuse.sort()
				for flag in any_iuse:
					flag_str = None
					isEnabled = False
					if flag in enabled_flags:
						isEnabled = True
						if is_new or flag in old_use and all_flags:
							flag_str = red(flag)
						elif flag not in old_iuse:
							flag_str = yellow(flag) + "%*"
						elif flag not in old_use:
							flag_str = green(flag) + "*"
					elif flag in removed_iuse:
						if all_flags:
							flag_str = yellow("-" + flag) + "%"
							if flag in old_use:
								flag_str += "*"
							flag_str = "(" + flag_str + ")"
							removed.append(flag_str)
						continue
					else:
						if is_new or flag in old_iuse and flag not in old_use and all_flags:
							flag_str = blue("-" + flag)
						elif flag not in old_iuse:
							flag_str = yellow("-" + flag)
							if flag not in iuse_forced:
								flag_str += "%"
						elif flag in old_use:
							flag_str = green("-" + flag) + "*"
					if flag_str:
						if flag in iuse_forced:
							flag_str = "(" + flag_str + ")"
						if isEnabled:
							enabled.append(flag_str)
						else:
							disabled.append(flag_str)

				if alphabetical:
					ret = " ".join(enabled)
				else:
					ret = " ".join(enabled + disabled + removed)
				if ret:
					ret = '%s="%s" ' % (name, ret)
				return ret

		if verbosity == 3:
			# FIXME: account for the possibility of different overlays in
			# /etc/make.conf vs. ${PORTAGE_CONFIGROOT}/etc/make.conf
			overlays = self.settings["PORTDIR_OVERLAY"].split()
			overlays_real = [os.path.realpath(t) \
				for t in self.settings["PORTDIR_OVERLAY"].split()]

		tree_nodes = []
		node_depth = {}
		i = 0
		depth = 0
		for x in mylist:
			graph_key = " ".join(x)
			if "--tree" in self.myopts:
				depth = len(tree_nodes)
				while depth and graph_key not in \
					self.digraph.child_nodes(tree_nodes[depth-1]):
						depth -= 1
				tree_nodes = tree_nodes[:depth]
				tree_nodes.append(graph_key)
			node_depth[graph_key] = depth

		last_merge_depth = 0
		for i in xrange(len(mylist)-1,-1,-1):
			graph_key = " ".join(mylist[i])
			if mylist[i][-1] != "nomerge":
				last_merge_depth = node_depth[graph_key]
				continue
			if node_depth[graph_key] >= last_merge_depth or \
				i < len(mylist) - 1 and \
				node_depth[graph_key] >= node_depth[" ".join(mylist[i+1])]:
					del mylist[i]
					del node_depth[graph_key]
		del tree_nodes

		display_overlays=False
		# files to fetch list - avoids counting a same file twice
		# in size display (verbose mode)
		myfetchlist=[]
		for x in mylist:
			pkg_type = x[0]
			myroot = x[1]
			pkg_key = x[2]
			portdb = self.trees[myroot]["porttree"].dbapi
			bindb  = self.trees[myroot]["bintree"].dbapi
			vartree = self.trees[myroot]["vartree"]
			pkgsettings = self.pkgsettings[myroot]
			pkgsettings.setcpv(pkg_key)
			if pkg_key not in self.useFlags[myroot]:
				if "binary" == pkg_type:
					self.useFlags[myroot][pkg_key] = bindb.aux_get(
							pkg_key, ["USE"])[0].split()
				elif "ebuild" == pkg_type:
					self.useFlags[myroot][pkg_key] = pkgsettings["USE"].split()

			fetch=" "

			if x[0]=="blocks":
				addl=""+red("B")+"  "+fetch+"  "
				resolved = self.trees[x[1]]["vartree"].resolve_key(x[2])
				print "["+x[0]+" "+addl+"]",red(resolved),
				block_parents = self.digraph.parent_nodes(" ".join(x))
				block_parents = [pnode.split()[2] for pnode in block_parents]
				block_parents = ", ".join(block_parents)
				if resolved!=x[2]:
					print bad("(\"%s\" is blocking %s)") % \
						(pkg_key, block_parents)
				else:
					print bad("(is blocking %s)") % block_parents
			else:
				if x[0] != "binary" and \
					"fetch" in portdb.aux_get(
					x[2], ["RESTRICT"])[0].split():
					fetch = red("F")
					if portdb.fetch_check(
						pkg_key, self.useFlags[myroot][pkg_key]):
						fetch = green("f")

				#we need to use "--emptrytree" testing here rather than "empty" param testing because "empty"
				#param is used for -u, where you still *do* want to see when something is being upgraded.
				myoldbest=""
				if "--emptytree" not in self.myopts and \
					self.trees[x[1]]["vartree"].exists_specific(x[2]):
					addl="  "+yellow("R")+fetch+"  "
				elif "--emptytree" not in self.myopts and \
					self.trees[x[1]]["vartree"].exists_specific_cat(x[2]):
					if x[0] == "binary":
						mynewslot = \
							self.trees[myroot]["bintree"].getslot(pkg_key)
					elif x[0] == "ebuild":
						mynewslot = \
							self.trees[myroot]["porttree"].getslot(pkg_key)
					myoldlist = self.trees[x[1]]["vartree"].dbapi.match(
						portage.pkgsplit(x[2])[0])
					myinslotlist = [inst_pkg for inst_pkg in myoldlist
						if mynewslot == vartree.getslot(inst_pkg)]
					if myinslotlist:
						myoldbest=portage.best(myinslotlist)
						addl="   "+fetch
						if portage.pkgcmp(portage.pkgsplit(x[2]), portage.pkgsplit(myoldbest)) < 0:
							# Downgrade in slot
							addl+=turquoise("U")+blue("D")
						else:
							# Update in slot
							addl+=turquoise("U")+" "
					else:
						# New slot, mark it new.
						addl=" "+green("NS")+fetch+"  "

					if "--changelog" in self.myopts:
						changelogs.extend(self.calc_changelog(
							portdb.findname(pkg_key),
							self.trees[x[1]]["vartree"].dep_bestmatch(
							'/'.join(portage.catpkgsplit(x[2])[:2])), x[2]))
				else:
					addl=" "+green("N")+" "+fetch+"  "

				verboseadd=""
				
				if pkg_key in self.useFlags[myroot]:
					# USE flag display
					if x[0] == "binary":
						cur_iuse = bindb.aux_get(pkg_key, ["IUSE"])[0].split()
					elif x[0] == "ebuild":
						cur_iuse = portdb.aux_get(pkg_key, ["IUSE"])[0].split()
					else:
						cur_iuse = []

					forced_flags = set()
					forced_flags.update(pkgsettings.useforce)
					forced_flags.update(pkgsettings.puseforce)
					forced_flags.update(pkgsettings.usemask)
					forced_flags.update(pkgsettings.pusemask)

					cur_iuse = portage.unique_array(cur_iuse)
					cur_iuse.sort()
					cur_use = self.useFlags[myroot][pkg_key]
					cur_use = [flag for flag in cur_use if flag in cur_iuse]

					if myoldbest:
						pkg = myoldbest
					else:
						pkg = x[2]
					if self.trees[x[1]]["vartree"].dbapi.cpv_exists(pkg):
						old_iuse, old_use = \
							self.trees[x[1]]["vartree"].dbapi.aux_get(
								pkg, ["IUSE", "USE"])
						old_iuse = portage.unique_array(old_iuse.split())
						old_iuse.sort()
						old_use = old_use.split()
						is_new = False
					else:
						old_iuse = []
						old_use = []
						is_new = True

					old_use = [flag for flag in old_use if flag in old_iuse]

					use_expand = pkgsettings["USE_EXPAND"].lower().split()
					use_expand.sort()
					use_expand.reverse()
					use_expand_hidden = \
						pkgsettings["USE_EXPAND_HIDDEN"].lower().split()

					def map_to_use_expand(myvals, forcedFlags=False):
						ret = {}
						forced = {}
						for exp in use_expand:
							ret[exp] = []
							forced[exp] = set()
							for val in myvals[:]:
								if val.startswith(exp.lower()+"_"):
									if val in forced_flags:
										forced[exp].add(val[len(exp)+1:])
									ret[exp].append(val[len(exp)+1:])
									myvals.remove(val)
						ret["USE"] = myvals
						forced["USE"] = [val for val in myvals \
							if val in forced_flags]
						for exp in use_expand_hidden:
							if exp in ret:
								del ret[exp]
						if forcedFlags:
							return ret, forced
						return ret

					cur_iuse_map, iuse_forced = \
						map_to_use_expand(cur_iuse, forcedFlags=True)
					cur_use_map = map_to_use_expand(cur_use)
					old_iuse_map = map_to_use_expand(old_iuse)
					old_use_map = map_to_use_expand(old_use)

					use_expand.sort()
					use_expand.insert(0, "USE")
					
					for key in use_expand:
						if key in use_expand_hidden:
							continue
						verboseadd += create_use_string(key.upper(),
							cur_iuse_map[key], iuse_forced[key],
							cur_use_map[key], old_iuse_map[key],
							old_use_map[key], is_new)

				if verbosity == 3:
					# size verbose
					mysize=0
					if x[0] == "ebuild" and x[-1]!="nomerge":
						myfilesdict = portdb.getfetchsizes(
							pkg_key, useflags=self.useFlags[myroot][pkg_key],
							debug=self.edebug)
						if myfilesdict is None:
							myfilesdict="[empty/missing/bad digest]"
						else:
							for myfetchfile in myfilesdict.keys():
								if myfetchfile not in myfetchlist:
									mysize+=myfilesdict[myfetchfile]
									myfetchlist.append(myfetchfile)
							totalsize+=mysize
						verboseadd+=format_size(mysize)+" "

					# overlay verbose
					# XXX: Invalid binaries have caused tracebacks here. 'if file_name'
					# x = ['binary', '/', 'sys-apps/pcmcia-cs-3.2.7.2.6', 'merge']
					file_name = portdb.findname(pkg_key)
					if file_name: # It might not exist in the tree
						dir_name=os.path.abspath(os.path.dirname(file_name)+"/../..")
						if (overlays_real.count(dir_name)>0):
							verboseadd+=teal("["+str(overlays_real.index(
								os.path.normpath(dir_name))+1)+"]")+" "
							display_overlays=True
					else:
						verboseadd += "[No ebuild?]"

				xs=portage.pkgsplit(x[2])
				if xs[2]=="r0":
					xs[2]=""
				else:
					xs[2]="-"+xs[2]

				mywidth = 130
				if "COLUMNWIDTH" in self.settings:
					try:
						mywidth = int(self.settings["COLUMNWIDTH"])
					except ValueError, e:
						portage.writemsg("!!! %s\n" % str(e), noiselevel=-1)
						portage.writemsg(
							"!!! Unable to parse COLUMNWIDTH='%s'\n" % \
							self.settings["COLUMNWIDTH"], noiselevel=-1)
						del e
				oldlp=mywidth-30
				newlp=oldlp-30

				indent = " " * node_depth[" ".join(x)]

				if myoldbest:
					myoldbest=portage.pkgsplit(myoldbest)[1]+"-"+portage.pkgsplit(myoldbest)[2]
					if myoldbest[-3:]=="-r0":
						myoldbest=myoldbest[:-3]
					myoldbest=blue("["+myoldbest+"]")

				if x[1]!="/":
					if myoldbest:
						myoldbest +=" "
					if "--columns" in self.myopts:
						if "--quiet" in self.myopts:
							myprint=addl+" "+indent+darkgreen(xs[0])
							myprint=myprint+darkblue(" "+xs[1]+xs[2])+" "
							myprint=myprint+myoldbest
							myprint=myprint+darkgreen("to "+x[1])
						else:
							myprint="["+x[0]+" "+addl+"] "+indent+darkgreen(xs[0])
							if (newlp-nc_len(myprint)) > 0:
								myprint=myprint+(" "*(newlp-nc_len(myprint)))
							myprint=myprint+"["+darkblue(xs[1]+xs[2])+"] "
							if (oldlp-nc_len(myprint)) > 0:
								myprint=myprint+" "*(oldlp-nc_len(myprint))
							myprint=myprint+myoldbest
							myprint=myprint+darkgreen("to "+x[1])+" "+verboseadd
					else:
						myprint="["+x[0]+" "+addl+"] "+darkgreen(x[2])+" "+myoldbest+darkgreen("to "+x[1])+" "+verboseadd
				else:
					if "--columns" in self.myopts:
						if "--quiet" in self.myopts:
							myprint=addl+" "+indent+darkgreen(xs[0])
							myprint=myprint+" "+green(xs[1]+xs[2])+" "
							myprint=myprint+myoldbest
						else:
							myprint="["+x[0]+" "+addl+"] "+indent+darkgreen(xs[0])
							if (newlp-nc_len(myprint)) > 0:
								myprint=myprint+(" "*(newlp-nc_len(myprint)))
							myprint=myprint+green(" ["+xs[1]+xs[2]+"] ")
							if (oldlp-nc_len(myprint)) > 0:
								myprint=myprint+(" "*(oldlp-nc_len(myprint)))
							myprint=myprint+myoldbest+"  "+verboseadd
					else:
						if x[3]=="nomerge":
							myprint=darkblue("[nomerge      ] "+indent+x[2]+" "+myoldbest+" ")+verboseadd
						else:
							myprint="["+x[0]+" "+addl+"] "+indent+darkgreen(x[2])+" "+myoldbest+" "+verboseadd
				p.append(myprint)

			mysplit = portage.pkgsplit(x[2])
			if "--tree" not in self.myopts and mysplit and \
				len(mysplit) == 3 and mysplit[0] == "sys-apps/portage" and \
				x[1] == "/":

				if mysplit[2] == "r0":
					myversion = mysplit[1]
				else:
					myversion = "%s-%s" % (mysplit[1], mysplit[2])

				if myversion != portage.VERSION :
					if "--emptytree" in self.myopts:
						p.append(colorize("WARN", "***")+" Please update portage to the above version before proceeding.")
						p.append("    Failure to do so may result in failed or improper merges.")
						p.append("    A simple '"+green("emerge portage")+"' is sufficient.")
						p.append("")
					elif mylist.index(x) < len(mylist) - 1 and \
						"livecvsportage" not in self.settings.features:
						p.append(colorize("WARN", "*** Portage will stop merging at this point and reload itself,"))
						p.append(colorize("WARN", "    then resume the merge."))
						print
			del mysplit

		for x in p:
			print x

		if verbosity == 3:
			print
			print "Total size of downloads: "+format_size(totalsize)
			if overlays and display_overlays:
				print "Portage overlays:"
				y=0
				for x in overlays:
					y=y+1
					print " "+teal("["+str(y)+"]"),x

		if "--changelog" in self.myopts:
			print
			for revision,text in changelogs:
				print bold('*'+revision)
				sys.stdout.write(text)

	def calc_changelog(self,ebuildpath,current,next):
		current = '-'.join(portage.catpkgsplit(current)[1:])
		if current.endswith('-r0'): current = current[:-3]
		next = '-'.join(portage.catpkgsplit(next)[1:])
		if next.endswith('-r0'): next = next[:-3]
		changelogpath = os.path.join(os.path.split(ebuildpath)[0],'ChangeLog')
		try:
			changelog = open(changelogpath).read()
		except SystemExit, e:
			raise # Needed else can't exit
		except:
			return []
		divisions = self.find_changelog_tags(changelog)
		#print 'XX from',current,'to',next
		#for div,text in divisions: print 'XX',div
		# skip entries for all revisions above the one we are about to emerge
		for i in range(len(divisions)):
			if divisions[i][0]==next:
				divisions = divisions[i:]
				break
		# find out how many entries we are going to display
		for i in range(len(divisions)):
			if divisions[i][0]==current:
				divisions = divisions[:i]
				break
		else:
		    # couldnt find the current revision in the list. display nothing
			return []
		return divisions

	def find_changelog_tags(self,changelog):
		divs = []
		release = None
		while 1:
			match = re.search(r'^\*\ ?([-a-zA-Z0-9_.+]*)(?:\ .*)?\n',changelog,re.M)
			if match is None:
				if release is not None:
					divs.append((release,changelog))
				return divs
			if release is not None:
				divs.append((release,changelog[:match.start()]))
			changelog = changelog[match.end():]
			release = match.group(1)
			if release.endswith('.ebuild'):
				release = release[:-7]
			if release.endswith('-r0'):
				release = release[:-3]

	def outdated(self):
		return self.outdatedpackages

class MergeTask(object):

	def __init__(self, settings, trees, myopts):
		self.settings = settings
		self.target_root = settings["ROOT"]
		self.trees = trees
		self.myopts = myopts
		self.edebug = 0
		if settings.get("PORTAGE_DEBUG", "") == "1":
			self.edebug = 1
		self.pkgsettings = {}
		self.pkgsettings[self.target_root] = portage.config(clone=settings)
		if self.target_root != "/":
			self.pkgsettings["/"] = \
				portage.config(clone=trees["/"]["vartree"].settings)

	def merge(self, mylist, favorites, mtimedb):
		returnme=0
		mymergelist=[]
		ldpath_mtimes = mtimedb["ldpath"]
		xterm_titles = "notitles" not in self.settings.features

		#check for blocking dependencies
		if "--fetchonly" not in self.myopts and \
			"--buildpkgonly" not in self.myopts:
			for x in mylist:
				if x[0]=="blocks":
					print "\n!!! Error: the "+x[2]+" package conflicts with another package;"
					print   "!!!        the two packages cannot be installed on the same system together."
					print   "!!!        Please use 'emerge --pretend' to determine blockers."
					if "--quiet" not in self.myopts:
						show_blocker_docs_link()
					if "--pretend" not in self.myopts:
						try:
							del mtimedb["resume"]
						except KeyError:
							pass
						sys.exit(1)

		#buildsyspkg: I need mysysdict also on resume (moved from the else block)
		mysysdict = genericdict(getlist(self.settings, "system"))
		if "--resume" in self.myopts:
			# We're resuming.
			print colorize("GOOD", "*** Resuming merge...")
			emergelog(xterm_titles, " *** Resuming merge...")
			mymergelist=mtimedb["resume"]["mergelist"][:]
			if "--skipfirst" in self.myopts and mymergelist:
				del mtimedb["resume"]["mergelist"][0]
				del mymergelist[0]
				mtimedb.commit()
			validate_merge_list(self.trees, mymergelist)
		else:
			myfavs = portage.grabfile(
				os.path.join(self.target_root, portage.WORLD_FILE))
			myfavdict=genericdict(myfavs)
			for x in range(len(mylist)):
				if mylist[x][3]!="nomerge":
					# Add to the mergelist
					mymergelist.append(mylist[x])
				else:
					myfavkey=portage.cpv_getkey(mylist[x][2])
					if "--onlydeps" in self.myopts:
						continue
					# Add to the world file. Since we won't be able to later.
					if "--fetchonly" not in self.myopts and \
						myfavkey in favorites:
						#don't record if already in system profile or already recorded
						if (not mysysdict.has_key(myfavkey)) and (not myfavdict.has_key(myfavkey)):
							#we don't have a favorites entry for this package yet; add one
							myfavdict[myfavkey]=myfavkey
							print ">>> Recording",myfavkey,"in \"world\" favorites file..."
			if not ("--fetchonly" in self.myopts or \
				"--fetch-all-uri" in self.myopts or \
				"--pretend" in self.myopts):
				portage.write_atomic(
					os.path.join(self.target_root, portage.WORLD_FILE),
					"\n".join(myfavdict.values()))

			mtimedb["resume"]["mergelist"]=mymergelist[:]
			mtimedb.commit()

		myfeat = self.settings.features[:]
		bad_resume_opts = set(["--ask", "--tree", "--changelog", "--skipfirst",
			"--resume"])
		if "parallel-fetch" in myfeat and \
			not ("--pretend" in self.myopts or \
			"--fetch-all-uri" in self.myopts or \
			"--fetchonly" in self.myopts):
			if "distlocks" not in myfeat:
				print red("!!!")
				print red("!!!")+" parallel-fetching requires the distlocks feature enabled"
				print red("!!!")+" you have it disabled, thus parallel-fetching is being disabled"
				print red("!!!")
			elif len(mymergelist) > 1:
				print ">>> starting parallel fetching"
				fetch_log = "/var/log/emerge-fetch.log"
				logfile = open(fetch_log, "w")
				fd_pipes = {1:logfile.fileno(), 2:logfile.fileno()}
				portage_util.apply_secpass_permissions(fetch_log,
					uid=portage.portage_uid, gid=portage.portage_gid,
					mode=0660)
				fetch_env = os.environ.copy()
				fetch_env["FEATURES"] = fetch_env.get("FEATURES", "") + " -cvs"
				fetch_env["PORTAGE_NICENESS"] = "0"
				fetch_args = [sys.argv[0], "--resume", "--fetchonly"]
				for arg in self.myopts:
					if arg not in bad_resume_opts:
						fetch_args.append(arg)
				portage.portage_exec.spawn(fetch_args, env=fetch_env,
					fd_pipes=fd_pipes, returnpid=True)
				logfile.close() # belongs to the spawned process

		mergecount=0
		for x in mymergelist:
			mergecount+=1
			myroot=x[1]
			pkg_key = x[2]
			pkgindex=2
			portdb = self.trees[myroot]["porttree"].dbapi
			bindb  = self.trees[myroot]["bintree"].dbapi
			vartree = self.trees[myroot]["vartree"]
			pkgsettings = self.pkgsettings[myroot]
			if x[0]=="blocks":
				pkgindex=3
			y = portdb.findname(pkg_key)
			if "--pretend" not in self.myopts:
				print "\n>>> Emerging (" + \
					colorize("MERGE_LIST_PROGRESS", str(mergecount)) + " of " + \
					colorize("MERGE_LIST_PROGRESS", str(len(mymergelist))) + ") " + \
					colorize("GOOD", x[pkgindex]) + " to " + x[1]
				emergelog(xterm_titles, " >>> emerge ("+\
					str(mergecount)+" of "+str(len(mymergelist))+\
					") "+x[pkgindex]+" to "+x[1])

			pkgsettings["EMERGE_FROM"] = x[0]
			pkgsettings.backup_changes("EMERGE_FROM")
			pkgsettings.reset()

			#buildsyspkg: Check if we need to _force_ binary package creation
			issyspkg = ("buildsyspkg" in myfeat) \
					and x[0] != "blocks" \
					and mysysdict.has_key(portage.cpv_getkey(x[2])) \
					and "--buildpkg" not in self.myopts
			if x[0] in ["ebuild","blocks"]:
				if x[0] == "blocks" and "--fetchonly" not in self.myopts:
					raise Exception, "Merging a blocker"
				elif "--fetchonly" in self.myopts or \
					"--fetch-all-uri" in self.myopts:
					if "--fetch-all-uri" in self.myopts:
						retval = portage.doebuild(y, "fetch", myroot,
							pkgsettings, self.edebug,
							"--pretend" in self.myopts, fetchonly=1,
							fetchall=1, mydbapi=portdb, tree="porttree")
					else:
						retval = portage.doebuild(y, "fetch", myroot,
							pkgsettings, self.edebug,
							"--pretend" in self.myopts, fetchonly=1,
							mydbapi=portdb, tree="porttree")
					if (retval is None) or retval:
						print
						print "!!! Fetch for",y,"failed, continuing..."
						print
						returnme=1
					continue
				elif "--buildpkg" in self.myopts or issyspkg:
					#buildsyspkg: Sounds useful to display something, but I don't know if we should also log it
					if issyspkg:
						print ">>> This is a system package, let's pack a rescue tarball."
						#emergelog(">>> This is a system package, let's pack a rescue tarball.")
					#create pkg, then merge pkg
					short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Clean"
					emergelog(xterm_titles, " === ("+str(mergecount)+\
						" of "+str(len(mymergelist))+") Cleaning ("+\
						x[pkgindex]+"::"+y+")", short_msg=short_msg)
					retval = portage.doebuild(y, "clean", myroot,
						pkgsettings, self.edebug, cleanup=1,
						mydbapi=portdb, tree="porttree")
					if (retval is None):
						portage_util.writemsg("Unable to run required binary.\n",
							noiselevel=-1)
						sys.exit(127)
					if retval:
						sys.exit(retval)
					short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Compile"
					emergelog(xterm_titles, " === ("+str(mergecount)+\
						" of "+str(len(mymergelist))+\
						") Compiling/Packaging ("+x[pkgindex]+"::"+y+\
						")", short_msg=short_msg)
					retval = portage.doebuild(y, "package", myroot,
						pkgsettings, self.edebug, mydbapi=portdb,
						tree="porttree")
					if (retval is None):
						portage_util.writemsg("Unable to run required binary.\n",
							noiselevel=-1)
						sys.exit(127)
					if retval:
						sys.exit(retval)
					#dynamically update our database
					if "--buildpkgonly" not in self.myopts:
						self.trees[myroot]["bintree"].inject(pkg_key)
						mytbz2 = self.trees[myroot]["bintree"].getname(pkg_key)
						short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Merge"
						emergelog(xterm_titles, " === ("+\
							str(mergecount)+" of "+\
							str(len(mymergelist))+") Merging ("+\
							x[pkgindex]+"::"+y+")", short_msg=short_msg)

						retval = portage.merge(pkgsettings["CATEGORY"],
							pkgsettings["PF"], pkgsettings["D"],
							os.path.join(pkgsettings["PORTAGE_BUILDDIR"],
							"build-info"), myroot, pkgsettings,
							myebuild=pkgsettings["EBUILD"],
							mytree="porttree", mydbapi=portdb,
							vartree=self.trees[myroot]["vartree"],
							prev_mtimes=ldpath_mtimes)
						if retval:
							sys.exit(retval)
					elif "noclean" not in pkgsettings.features:
						portage.doebuild(y, "clean", myroot, pkgsettings,
							self.edebug, mydbapi=portdb, tree="porttree")
				else:
					short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Clean"
					emergelog(xterm_titles, " === ("+str(mergecount)+\
						" of "+str(len(mymergelist))+") Cleaning ("+\
						x[pkgindex]+"::"+y+")", short_msg=short_msg)
					retval = portage.doebuild(y, "clean", myroot,
						pkgsettings, self.edebug, cleanup=1,
						mydbapi=portdb, tree="porttree")
					if (retval is None):
						portage_util.writemsg("Unable to run required binary.\n",
							noiselevel=-1)
						sys.exit(127)
					if retval:
						sys.exit(retval)
					short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Compile"
					emergelog(xterm_titles, " === ("+str(mergecount)+\
						" of "+str(len(mymergelist))+\
						") Compiling/Merging ("+x[pkgindex]+\
						"::"+y+")", short_msg=short_msg)
					retval = portage.doebuild(y, "merge", myroot,
						pkgsettings, self.edebug,
						vartree=self.trees[myroot]["vartree"],
						mydbapi=portdb, tree="porttree",
						prev_mtimes=ldpath_mtimes)
					if (retval is None):
						portage_util.writemsg("Unable to run required binary.\n",
							noiselevel=-1)
						sys.exit(127)
					if retval:
						sys.exit(retval)
					#dynamically update our database
			elif x[0]=="binary":
				#merge the tbz2
				mytbz2 = self.trees[myroot]["bintree"].getname(pkg_key)
				if self.trees[myroot]["bintree"].isremote(pkg_key):
					short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Fetch"
					emergelog(xterm_titles, " --- ("+str(mergecount)+\
						" of "+str(len(mymergelist))+\
						") Fetching Binary ("+x[pkgindex]+\
						"::"+mytbz2+")", short_msg=short_msg)
					if not self.trees[myroot]["bintree"].gettbz2(pkg_key):
						sys.exit(1)

				if "--fetchonly" in self.myopts or \
					"--fetch-all-uri" in self.myopts:
					continue

				short_msg = "emerge: ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[pkgindex]+" Merge Binary"
				emergelog(xterm_titles, " === ("+str(mergecount)+\
					" of "+str(len(mymergelist))+") Merging Binary ("+\
					x[pkgindex]+"::"+mytbz2+")", short_msg=short_msg)
				retval = portage.pkgmerge(mytbz2, x[1], pkgsettings,
					mydbapi=bindb,
					vartree=self.trees[myroot]["vartree"],
					prev_mtimes=ldpath_mtimes)
				if retval is None:
					sys.exit(1)
				#need to check for errors
			if "--buildpkgonly" not in self.myopts:
				self.trees[x[1]]["vartree"].inject(x[2])
				myfavkey=portage.cpv_getkey(x[2])
				if "--fetchonly" not in self.myopts and \
					"--fetch-all-uri" not in self.myopts and \
					myfavkey in favorites:
					myfavs = portage.grabfile(os.path.join(myroot, portage.WORLD_FILE))
					myfavdict=genericdict(myfavs)
					#don't record if already in system profile or already recorded
					if (not mysysdict.has_key(myfavkey)) and (not myfavdict.has_key(myfavkey)):
						#we don't have a favorites entry for this package yet; add one
						myfavdict[myfavkey]=myfavkey
						print ">>> Recording",myfavkey,"in \"world\" favorites file..."
						emergelog(xterm_titles, " === ("+\
							str(mergecount)+" of "+\
							str(len(mymergelist))+\
							") Updating world file ("+x[pkgindex]+")")
						portage.write_atomic(
						os.path.join(myroot, portage.WORLD_FILE),
						"\n".join(myfavdict.values()))

				if "--pretend" not in self.myopts and \
					"--fetchonly" not in self.myopts and \
					"--fetch-all-uri" not in self.myopts:
					# Clean the old package that we have merged over top of it.
					if pkgsettings.get("AUTOCLEAN", "yes") == "yes":
						xsplit=portage.pkgsplit(x[2])
						emergelog(xterm_titles, " >>> AUTOCLEAN: " + xsplit[0])
						retval = unmerge(pkgsettings, self.myopts, vartree,
							"clean", [xsplit[0]], ldpath_mtimes)
						if not retval:
							emergelog(xterm_titles,
								" --- AUTOCLEAN: Nothing unmerged.")
					else:
						portage.writemsg_stdout(colorize("WARN", "WARNING:")
							+ " AUTOCLEAN is disabled.  This can cause serious"
							+ " problems due to overlapping packages.\n")

					# Figure out if we need a restart.
					mysplit=portage.pkgsplit(x[2])
					if mysplit[0] == "sys-apps/portage" and x[1] == "/":
						myver=mysplit[1]+"-"+mysplit[2]
						if myver[-3:]=='-r0':
							myver=myver[:-3]
						if (myver != portage.VERSION) and \
						   "livecvsportage" not in self.settings.features:
							if len(mymergelist) > mergecount:
								emergelog(xterm_titles,
									" ::: completed emerge ("+ \
									str(mergecount)+" of "+ \
									str(len(mymergelist))+") "+ \
									x[2]+" to "+x[1])
								emergelog(xterm_titles, " *** RESTARTING " + \
									"emerge via exec() after change of " + \
									"portage version.")
								del mtimedb["resume"]["mergelist"][0]
								mtimedb.commit()
								portage.run_exitfuncs()
								mynewargv=[sys.argv[0],"--resume"]
								for arg in self.myopts:
									if arg in bad_resume_opts:
										continue
									mynewargv.append(arg)
								# priority only needs to be adjusted on the first run
								os.environ["PORTAGE_NICENESS"] = "0"
								os.execv(mynewargv[0], mynewargv)

			if "--pretend" not in self.myopts and \
				"--fetchonly" not in self.myopts and \
				"--fetch-all-uri" not in self.myopts:
				if "noclean" not in self.settings.features:
					short_msg = "emerge: (%s of %s) %s Clean Post" % \
						(mergecount, len(mymergelist), x[pkgindex])
					emergelog(xterm_titles, (" === (%s of %s) " + \
						"Post-Build Cleaning (%s::%s)") % \
						(mergecount, len(mymergelist), x[pkgindex], y),
						short_msg=short_msg)
				emergelog(xterm_titles, " ::: completed emerge ("+\
					str(mergecount)+" of "+str(len(mymergelist))+") "+\
					x[2]+" to "+x[1])

			# Unsafe for parallel merges
			del mtimedb["resume"]["mergelist"][0]
			# Commit after each merge so that --resume may still work in
			# in the event that portage is not allowed to exit normally
			# due to power failure, SIGKILL, etc...
			mtimedb.commit()

		if "--pretend" not in self.myopts:
			emergelog(xterm_titles, " *** Finished. Cleaning up...")

		# We're out of the loop... We're done. Delete the resume data.
		if mtimedb.has_key("resume"):
			del mtimedb["resume"]
		mtimedb.commit()

		#by doing an exit this way, --fetchonly can continue to try to
		#fetch everything even if a particular download fails.
		if "--fetchonly" in self.myopts or "--fetch-all-uri" in self.myopts:
			if returnme:
				print "\n\n!!! Some fetch errors were encountered.  Please see above for details.\n\n"
				sys.exit(returnme)
			else:
				sys.exit(0)

def unmerge(settings, myopts, vartree, unmerge_action, unmerge_files,
	ldpath_mtimes, raise_on_missing=True):
	candidate_catpkgs=[]
	global_unmerge=0
	xterm_titles = "notitles" not in settings.features

	realsyslist = getlist(settings, "system")
	syslist = []
	for x in realsyslist:
		mycp = portage.dep_getkey(x)
		if mycp in settings.getvirtuals():
			providers = []
			for provider in settings.getvirtuals()[mycp]:
				if vartree.dbapi.match(provider):
					providers.append(provider)
			if len(providers) == 1:
				syslist.extend(providers)
		else:
			syslist.append(mycp)

	mysettings = portage.config(clone=settings)

	if not unmerge_files or "world" in unmerge_files or "system" in unmerge_files:
		if "unmerge"==unmerge_action:
			print
			print bold("emerge unmerge")+" can only be used with specific package names, not with "+bold("world")+" or"
			print bold("system")+" targets."
			print
			return 0
		else:
			global_unmerge=1

	localtree = vartree
	# process all arguments and add all valid db entries to candidate_catpkgs
	if global_unmerge:
		if not unmerge_files or "world" in unmerge_files:
			candidate_catpkgs.extend(localtree.getallnodes())
		elif "system" in unmerge_files:
			candidate_catpkgs.extend(getlist(settings, "system"))
	else:
		#we've got command-line arguments
		if not unmerge_files:
			print "\nNo packages to unmerge have been provided.\n"
			return 0
		for x in unmerge_files:
			arg_parts=x.split('/')
			if (x[0] not in [".","/"]) and (arg_parts[-1][-7:] != ".ebuild"):
				#possible cat/pkg or dep; treat as such
				candidate_catpkgs.append(x)
			elif unmerge_action in ["prune","clean"]:
				print "\n!!! Prune and clean do not accept individual ebuilds as arguments;\n    skipping.\n"
				continue
			else:
				# it appears that the user is specifying an installed ebuild and we're in "unmerge" mode, so it's
				# ok.
				if not os.path.exists(x):
					print "\n!!! The path '"+x+"' doesn't exist.\n"
					return 0

				absx   = os.path.abspath(x)
				sp_absx = absx.split("/")
				if sp_absx[-1][-7:] == ".ebuild":
					del sp_absx[-1]
					absx = string.join(sp_absx,"/")

				sp_absx_len = len(sp_absx)

				vdb_path = os.path.join(settings["ROOT"], portage.VDB_PATH)
				vdb_len  = len(vdb_path)

				sp_vdb     = vdb_path.split("/")
				sp_vdb_len = len(sp_vdb)

				if not os.path.exists(absx+"/CONTENTS"):
					print "!!! Not a valid db dir: "+str(absx)
					return 0

				if sp_absx_len <= sp_vdb_len:
					# The Path is shorter... so it can't be inside the vdb.
					print sp_absx
					print absx
					print "\n!!!",x,"cannot be inside "+vdb_path+"; aborting.\n"
					return 0

				for idx in range(0,sp_vdb_len):
					if (idx >= sp_absx_len) or (sp_vdb[idx] != sp_absx[idx]):
						print sp_absx
						print absx
						print "\n!!!",x,"is not inside "+vdb_path+"; aborting.\n"
						return 0

				print "="+string.join(sp_absx[sp_vdb_len:],"/")
				candidate_catpkgs.append("="+string.join(sp_absx[sp_vdb_len:],"/"))

	newline=""
	if (not "--quiet" in myopts):
		newline="\n"
	if settings["ROOT"] != "/":
		print darkgreen(newline+">>> Using system located in ROOT tree "+settings["ROOT"])
	if (("--pretend" in myopts) or ("--ask" in myopts)) and not ("--quiet" in myopts):
		print darkgreen(newline+">>> These are the packages that would be unmerged:")

	pkgmap={}
	numselected=0
	for x in candidate_catpkgs:
		#cycle through all our candidate deps and determine what will and will not get unmerged
		try:
			mymatch=localtree.dep_match(x)
		except KeyError:
			mymatch=None
		except ValueError, errpkgs:
			print "\n\n!!! The short ebuild name \"" + x + "\" is ambiguous.  Please specify"
			print "!!! one of the following fully-qualified ebuild names instead:\n"
			for i in errpkgs[0]:
				print "    " + green(i)
			print
			sys.exit(1)

		if not mymatch and x[0] not in "<>=~":
			#add a "=" if missing
			mymatch=localtree.dep_match("="+x)
		if not mymatch:
			if raise_on_missing:
				raise portage_exception.PackageNotFound(x)
			else:
				portage.writemsg("\n--- Couldn't find '%s' to %s.\n" % \
					(x, unmerge_action), noiselevel=-1)
				continue
		mykey = portage.key_expand(
			portage.dep_getkey(
				mymatch[0]), mydb=vartree.dbapi, settings=settings)
		if not pkgmap.has_key(mykey):
			pkgmap[mykey]={"protected":[], "selected":[], "omitted":[] }
		if unmerge_action=="unmerge":
				for y in mymatch:
					if y not in pkgmap[mykey]["selected"]:
						pkgmap[mykey]["selected"].append(y)
						numselected=numselected+len(mymatch)

		else:
			#unmerge_action in ["prune", clean"]
			slotmap={}
			for mypkg in mymatch:
				if unmerge_action=="clean":
					myslot=localtree.getslot(mypkg)
				else:
					#since we're pruning, we don't care about slots and put all the pkgs in together
					myslot=0
				if not slotmap.has_key(myslot):
					slotmap[myslot]={}
				slotmap[myslot][localtree.dbapi.cpv_counter(mypkg)]=mypkg
			for myslot in slotmap.keys():
				counterkeys=slotmap[myslot].keys()
				counterkeys.sort()
				if not counterkeys:
					continue
				counterkeys.sort()
				pkgmap[mykey]["protected"].append(slotmap[myslot][counterkeys[-1]])
				del counterkeys[-1]
				#be pretty and get them in order of merge:
				for ckey in counterkeys:
					pkgmap[mykey]["selected"].append(slotmap[myslot][ckey])
					numselected=numselected+1
				#ok, now the last-merged package is protected, and the rest are selected
	if global_unmerge and not numselected:
		print "\n>>> No outdated packages were found on your system.\n"
		return 0

	if not numselected:
		print "\n>>> No packages selected for removal by",unmerge_action+".\n"
		return 0

	for x in pkgmap.keys():
		for y in localtree.dep_match(x):
			if y not in pkgmap[x]["omitted"] and \
			   y not in pkgmap[x]["selected"] and \
			   y not in pkgmap[x]["protected"]:
				pkgmap[x]["omitted"].append(y)
		if global_unmerge and not pkgmap[x]["selected"]:
			#avoid cluttering the preview printout with stuff that isn't getting unmerged
			continue
		if not (pkgmap[x]["protected"] or pkgmap[x]["omitted"]) and (x in syslist):
			print colorize("BAD","\a\n\n!!! '%s' is part of your system profile." % x)
			print colorize("WARN","\a!!! Unmerging it may be damaging to your system.\n")
			if "--pretend" not in myopts and "--ask" not in myopts:
				countdown(int(settings["EMERGE_WARNING_DELAY"]),
					colorize("UNMERGE_WARN", "Press Ctrl-C to Stop"))
		print "\n "+white(x)
		for mytype in ["selected","protected","omitted"]:
			portage.writemsg_stdout((mytype + ": ").rjust(14), noiselevel=-1)
			if pkgmap[x][mytype]:
				for mypkg in pkgmap[x][mytype]:
					mysplit=portage.catpkgsplit(mypkg)
					if mysplit[3]=="r0":
						myversion=mysplit[2]
					else:
						myversion=mysplit[2]+"-"+mysplit[3]
					if mytype=="selected":
						portage.writemsg_stdout(
							colorize("UNMERGE_WARN", myversion + " "), noiselevel=-1)
					else:
						portage.writemsg_stdout(
							colorize("GOOD", myversion + " "), noiselevel=-1)
			else:
				portage.writemsg_stdout("none", noiselevel=-1)
			portage.writemsg_stdout("\n", noiselevel=-1)

	portage.writemsg_stdout("\n>>> " + colorize("UNMERGE_WARN", "'Selected'") + \
		" packages are slated for removal.\n")
	portage.writemsg_stdout(">>> " + colorize("GOOD", "'Protected'") + \
			" and " + colorize("GOOD", "'omitted'") + \
			" packages will not be removed.\n\n")

	if "--pretend" in myopts:
		#we're done... return
		return 0
	if "--ask" in myopts:
		if userquery("Would you like to unmerge these packages?")=="No":
			# enter pretend mode for correct formatting of results
			myopts+=["--pretend"]
			print
			print "Quitting."
			print
			return 0
	#the real unmerging begins, after a short delay....
	countdown(int(settings["CLEAN_DELAY"]), ">>> Unmerging")

	for x in pkgmap.keys():
		for y in pkgmap[x]["selected"]:
			print ">>> Unmerging "+y+"..."
			emergelog(xterm_titles, "=== Unmerging... ("+y+")")
			mysplit=string.split(y,"/")
			#unmerge...
			retval = portage.unmerge(mysplit[0], mysplit[1], settings["ROOT"],
				mysettings, unmerge_action not in ["clean","prune"],
				vartree=vartree, ldpath_mtimes=ldpath_mtimes)
			if retval != os.EX_OK:
				emergelog(xterm_titles, " !!! unmerge FAILURE: "+y)
			else:
				clean_world(vartree.dbapi, y)
				emergelog(xterm_titles, " >>> unmerge success: "+y)
	return 1

def chk_updated_info_files(root, infodirs, prev_mtimes, retval):

	print
	if os.path.exists("/usr/bin/install-info"):
		regen_infodirs=[]
		for z in infodirs:
			if z=='':
				continue
			inforoot=normpath(root+z)
			if os.path.isdir(inforoot):
				infomtime = os.stat(inforoot).st_mtime
				if inforoot not in prev_mtimes or \
					prev_mtimes[inforoot] != infomtime:
						regen_infodirs.append(inforoot)

		if not regen_infodirs:
			print " "+green("*")+" GNU info directory index is up-to-date."
		else:
			print " "+green("*")+" Regenerating GNU info directory index..."

			icount=0
			badcount=0
			for inforoot in regen_infodirs:
				if inforoot=='':
					continue
				try:
					os.rename(inforoot+"/dir",inforoot+"/dir.old")
				except SystemExit, e:
					raise # Needed else can't exit
				except:
					pass

				if not os.path.isdir(inforoot):
					continue
				errmsg = ""
				file_list = os.listdir(inforoot)
				file_list.sort()
				for x in file_list:
					if (x[0] == ".") or (x in ["dir","dir.old"]) or (os.path.isdir(inforoot+"/"+x)):
						continue
					myso=commands.getstatusoutput("LANG=C LANGUAGE=C /usr/bin/install-info --dir-file="+inforoot+"/dir "+inforoot+"/"+x)[1]
					existsstr="already exists, for file `"
					if myso!="":
						if re.search(existsstr,myso):
							# Already exists... Don't increment the count for this.
							pass
						elif myso[:44]=="install-info: warning: no info dir entry in ":
							# This info file doesn't contain a DIR-header: install-info produces this
							# (harmless) warning (the --quiet switch doesn't seem to work).
							# Don't increment the count for this.
							pass
						else:
							badcount=badcount+1
							errmsg += myso + "\n"
					icount=icount+1

				#update mtime so we can potentially avoid regenerating.
				prev_mtimes[inforoot] = os.stat(inforoot).st_mtime

			if badcount:
				print " "+yellow("*")+" Processed",icount,"info files;",badcount,"errors."
				print errmsg
			else:
				print " "+green("*")+" Processed",icount,"info files."


def post_emerge(settings, mtimedb, retval):
	target_root = settings["ROOT"]
	info_mtimes = mtimedb["info"]
	config_protect = settings.get("CONFIG_PROTECT","").split()
	infodirs = settings.get("INFOPATH","").split(":") + \
		settings.get("INFODIR","").split(":")

	os.chdir("/")

	emergelog("notitles" not in settings.features,
		" *** exiting successfully.")

	if "noinfo" not in settings.features:
		chk_updated_info_files(target_root, infodirs, info_mtimes, retval)

	chk_updated_cfg_files(target_root, config_protect)
	mtimedb.commit()
	sys.exit(retval)


def chk_updated_cfg_files(target_root, config_protect):
	if config_protect:
		#number of directories with some protect files in them
		procount=0
		for x in config_protect:
			x = os.path.join(target_root, x.lstrip(os.path.sep))
			try:
				mymode = os.lstat(x).st_mode
			except OSError:
				continue
			if stat.S_ISDIR(mymode):
				mycommand = "cd '%s'; find . -iname '._cfg????_*'" % x
			else:
				mycommand = "cd '%s'; find . -maxdepth 1 -iname '._cfg????_%s'" % \
					os.path.split(x.rstrip(os.path.sep))
			a = commands.getstatusoutput(mycommand)
			if a[0] != 0:
				print >> sys.stderr, " " + bad("*")+ " error scanning '%s'" % x
			else:
				files = a[1].split()
				if files:
					procount += 1
					print colorize("WARN", " * IMPORTANT:"),
					if stat.S_ISDIR(mymode):
						 print "%d config files in '%s' need updating." % \
							(len(files), x)
					else:
						 print "config file '%s' needs updating." % x

		if procount:
			#print " "+yellow("*")+" Type "+green("emerge --help config")+" to learn how to update config files."
			print " "+yellow("*")+" Type "+green("emerge --help config")+" to learn how to update config files."
		print

def is_valid_package_atom(x):
	testkey = portage.dep_getkey(x)
	if testkey.startswith("null/"):
		testatom = x.replace(testkey[5:], "cat/"+testkey[5:])
	elif "/" not in x:
		testatom = "cat/"+x
	else:
		testatom = x
	return portage.isvalidatom(testatom)

def validate_merge_list(trees, mergelist):
	"""Validate the list to make sure all the packages are still available.
	This is needed for --resume."""
	for (pkg_type, myroot, pkg_key, action) in mergelist:
		if pkg_type == "binary" and \
			not trees[myroot]["bintree"].dbapi.match("="+pkg_key) or \
			pkg_type == "ebuild" and \
			not trees[myroot]["porttree"].dbapi.xmatch(
			"match-all", "="+pkg_key):
			print red("!!! Error: The resume list contains packages that are no longer")
			print red("!!!        available to be emerged. Please restart/continue")
			print red("!!!        the merge operation manually.")
			sys.exit(1)

def show_blocker_docs_link():
	print
	print "For more information about " + bad("Blocked Packages") + ", please refer to the following"
	print "section of the Gentoo Linux x86 Handbook (architecture is irrelevant):"
	print
	print "http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?full=1#blocked"
	print

def action_sync(settings, trees, mtimedb, myopts, myaction):
	xterm_titles = "notitles" not in settings.features
	emergelog(xterm_titles, " === sync")
	myportdir=settings["PORTDIR"]
	if myportdir[-1]=="/":
		myportdir=myportdir[:-1]
	if not os.path.exists(myportdir):
		print ">>>",myportdir,"not found, creating it."
		os.makedirs(myportdir,0755)
	syncuri=string.rstrip(settings["SYNC"])
	os.umask(0022)
	if myaction == "metadata":
		print "skipping sync"
		updatecache_flg = True
		tmpservertimestampfile = None
	elif syncuri[:8]=="rsync://":
		if not os.path.exists("/usr/bin/rsync"):
			print "!!! /usr/bin/rsync does not exist, so rsync support is disabled."
			print "!!! Type \"emerge net-misc/rsync\" to enable rsync support."
			sys.exit(1)
		mytimeout=180

		rsync_opts = []

		if settings["PORTAGE_RSYNC_OPTS"] == "":
			portage.writemsg("PORTAGE_RSYNC_OPTS empty or unset, using hardcoded defaults\n")
			rsync_opts.extend([
				"--recursive",    # Recurse directories
				"--links",        # Consider symlinks
				"--safe-links",   # Ignore links outside of tree
				"--perms",        # Preserve permissions
				"--times",        # Preserive mod times
				"--compress",     # Compress the data transmitted
				"--force",        # Force deletion on non-empty dirs
				"--whole-file",   # Don't do block transfers, only entire files
				"--delete",       # Delete files that aren't in the master tree
				"--delete-after", # Delete only after everything else is done
				"--stats",        # Show final statistics about what was transfered
				"--timeout="+str(mytimeout), # IO timeout if not done in X seconds
				"--exclude='/distfiles'",   # Exclude distfiles from consideration
				"--exclude='/local'",       # Exclude local     from consideration
				"--exclude='/packages'",    # Exclude packages  from consideration
			])

		else:
			# The below validation is not needed when using the above hardcoded
			# defaults.

			portage.writemsg("Using PORTAGE_RSYNC_OPTS instead of hardcoded defaults\n", 1)
			rsync_opts.extend(settings["PORTAGE_RSYNC_OPTS"].split())

			for opt in ("--recursive", "--times"):
				if opt not in rsync_opts:
					portage.writemsg(yellow("WARNING:") + " adding required option " + \
					"%s not included in PORTAGE_RSYNC_OPTS\n" % opt)
					rsync_opts.append(opt)
	
			for exclude in ("distfiles", "local", "packages"):
				opt = "--exclude='/%s'" % exclude
				if opt not in rsync_opts:
					portage.writemsg(yellow("WARNING:") + \
					" adding required option %s not included in "  % opt + \
					"PORTAGE_RSYNC_OPTS (can be overridden with --exclude='!')\n")
					rsync_opts.append(opt)
	
			if settings["RSYNC_TIMEOUT"] != "":
				portage.writemsg("WARNING: usage of RSYNC_TIMEOUT is deprecated, " + \
				"use PORTAGE_RSYNC_EXTRA_OPTS instead\n")
				try:
					mytimeout = int(settings["RSYNC_TIMEOUT"])
					rsync_opts.append("--timeout=%d" % mytimeout)
				except ValueError, e:
					portage.writemsg("!!! %s\n" % str(e))
	
			# TODO: determine options required for official servers
			if syncuri.rstrip("/").endswith(".gentoo.org/gentoo-portage"):

				def rsync_opt_startswith(opt_prefix):
					for x in rsync_opts:
						if x.startswith(opt_prefix):
							return True
					return False

				if not rsync_opt_startswith("--timeout="):
					rsync_opts.append("--timeout=%d" % mytimeout)

				for opt in ("--compress", "--whole-file"):
					if opt not in rsync_opts:
						portage.writemsg(yellow("WARNING:") + " adding required option " + \
						"%s not included in PORTAGE_RSYNC_OPTS\n" % opt)
						rsync_opts.append(opt)

		if "--quiet" in myopts:
			rsync_opts.append("--quiet")    # Shut up a lot
		else:
			rsync_opts.append("--verbose")	# Print filelist

		if "--verbose" in myopts:
			rsync_opts.append("--progress")  # Progress meter for each file

		if "--debug" in myopts:
			rsync_opts.append("--checksum") # Force checksum on all files

		if settings["RSYNC_EXCLUDEFROM"] != "":
			portage.writemsg(yellow("WARNING:") + \
			" usage of RSYNC_EXCLUDEFROM is deprecated, use " + \
			"PORTAGE_RSYNC_EXTRA_OPTS instead\n")
			if os.path.exists(settings["RSYNC_EXCLUDEFROM"]):
				rsync_opts.append("--exclude-from=%s" % \
				settings["RSYNC_EXCLUDEFROM"])
			else:
				portage.writemsg("!!! RSYNC_EXCLUDEFROM specified," + \
				" but file does not exist.\n")

		if settings["RSYNC_RATELIMIT"] != "":
			portage.writemsg(yellow("WARNING:") + \
			" usage of RSYNC_RATELIMIT is deprecated, use " + \
			"PORTAGE_RSYNC_EXTRA_OPTS instead")
			rsync_opts.append("--bwlimit=%s" % \
			settings["RSYNC_RATELIMIT"])

		servertimestampdir  = settings.depcachedir+"/"
		servertimestampfile = settings.depcachedir+"/timestamp.chk"
		tmpservertimestampdir  = settings["PORTAGE_TMPDIR"]+"/"
		tmpservertimestampfile = settings["PORTAGE_TMPDIR"]+"/timestamp.chk"

		# We only use the backup if a timestamp exists in the portdir.
		content=None
		if os.path.exists(myportdir+"/metadata/timestamp.chk"):
			content=portage.grabfile(servertimestampfile)
		if (not content):
			content=portage.grabfile(myportdir+"/metadata/timestamp.chk")

		if (content):
			try:
				mytimestamp=time.mktime(time.strptime(content[0], "%a, %d %b %Y %H:%M:%S +0000"))
			except ValueError:
				mytimestamp=0
		else:
			mytimestamp=0

		if not os.path.exists(servertimestampdir):
			os.mkdir(servertimestampdir)
			os.chown(servertimestampdir, os.getuid(), portage.portage_gid)
			os.chmod(servertimestampdir, 02775)

		#exitcode=0
		try:
			if settings.has_key("RSYNC_RETRIES"):
				print yellow("WARNING:")+" usage of RSYNC_RETRIES is deprecated, use PORTAGE_RSYNC_RETRIES instead"
				maxretries=int(settings["RSYNC_RETRIES"])				
			else:
				maxretries=int(settings["PORTAGE_RSYNC_RETRIES"])
		except SystemExit, e:
			raise # Needed else can't exit
		except:
			maxretries=3 #default number of retries

		retries=0
		user_name, hostname, port = re.split(
			"rsync://([^:/]+@)?([^:/]*)(:[0-9]+)?", syncuri, maxsplit=3)[1:4]
		if port is None:
			port=""
		if user_name is None:
			user_name=""
		updatecache_flg=True
		all_rsync_opts = set(rsync_opts)
		all_rsync_opts.update(
			settings.get("PORTAGE_RSYNC_EXTRA_OPTS","").split())
		family = socket.AF_UNSPEC
		if "-4" in all_rsync_opts or "--ipv4" in all_rsync_opts:
			family = socket.AF_INET
		elif socket.has_ipv6 and \
			("-6" in all_rsync_opts or "--ipv6" in all_rsync_opts):
			family = socket.AF_INET6
		ips=[]
		while (1):
			if ips:
				del ips[0]
			if ips==[]:
				try:
					for addrinfo in socket.getaddrinfo(
						hostname, None, family, socket.SOCK_STREAM):
						if addrinfo[0] == socket.AF_INET6:
							# IPv6 addresses need to be enclosed in square brackets
							ips.append("[%s]" % addrinfo[4][0])
						else:
							ips.append(addrinfo[4][0])
				except SystemExit, e:
					raise # Needed else can't exit
				except Exception, e:
					print "Notice:",str(e)
					dosyncuri=syncuri

			if ips:
				try:
					dosyncuri = syncuri.replace(
						"//" + user_name + hostname + port + "/",
						"//" + user_name + ips[0] + port + "/", 1)
				except SystemExit, e:
					raise # Needed else can't exit
				except Exception, e:
					print "Notice:",str(e)
					dosyncuri=syncuri

			if (retries==0):
				if "--ask" in myopts:
					if userquery("Do you want to sync your Portage tree with the mirror at\n" + blue(dosyncuri) + bold("?"))=="No":
						print
						print "Quitting."
						print
						sys.exit(0)
				emergelog(xterm_titles, ">>> Starting rsync with " + dosyncuri)
				if "--quiet" not in myopts:
					print ">>> Starting rsync with "+dosyncuri+"..."
			else:
				emergelog(xterm_titles,
					">>> Starting retry %d of %d with %s" % \
						(retries,maxretries,dosyncuri))
				print "\n\n>>> Starting retry %d of %d with %s" % (retries,maxretries,dosyncuri)

			if "--quiet" not in myopts:
				print ">>> Checking server timestamp ..."

			rsynccommand = " ".join(["/usr/bin/rsync",
				settings["PORTAGE_RSYNC_EXTRA_OPTS"],
				" ".join(rsync_opts)])

			if "--debug" in myopts:
				print rsynccommand

			mycommand = " ".join([rsynccommand,
				dosyncuri + "/metadata/timestamp.chk",
				tmpservertimestampdir])
			exitcode=portage.spawn(mycommand,settings,free=1)
			if (exitcode==0):
				try:
					servertimestamp = time.mktime(time.strptime(portage.grabfile(tmpservertimestampfile)[0], "%a, %d %b %Y %H:%M:%S +0000"))
				except SystemExit, e:
					raise # Needed else can't exit
				except:
					servertimestamp = 0

				if (servertimestamp != 0) and (servertimestamp == mytimestamp):
					emergelog(xterm_titles,
						">>> Cancelling sync -- Already current.")
					print
					print ">>>"
					print ">>> Timestamps on the server and in the local repository are the same."
					print ">>> Cancelling all further sync action. You are already up to date."
					print ">>>"
					print
					sys.exit(0)
				elif (servertimestamp != 0) and (servertimestamp < mytimestamp):
					emergelog(xterm_titles,
						">>> Server out of date: %s" % dosyncuri)
					print
					print ">>>"
					print ">>> SERVER OUT OF DATE: %s" % dosyncuri
					print ">>>"
					print
				elif (servertimestamp == 0) or (servertimestamp > mytimestamp):
					# actual sync
					mycommand=rsynccommand+" "+dosyncuri+"/ "+myportdir
					exitcode=portage.spawn(mycommand,settings,free=1)
					if exitcode in [0,1,2,3,4,11,14,20,21]:
						break
			elif exitcode in [0,1,2,3,4,11,14,20,21]:
				break

			retries=retries+1

			if retries<=maxretries:
				print ">>> Retrying..."
				time.sleep(11)
			else:
				# over retries
				# exit loop
				updatecache_flg=False
				break

		if (exitcode==0):
			emergelog(xterm_titles, "=== Sync completed with %s" % dosyncuri)
			# save timestamp.chk for next timestamp check.
			try:
				if tmpservertimestampfile is not None:
					portage.movefile(tmpservertimestampfile,
						servertimestampfile, mysettings=settings)
			except SystemExit, e:
				raise
			except Exception, e:
				portage.writemsg("!!! Failed to save current timestamp.\n",
					noiselevel=-1)
				portage.writemsg("!!! %s\n" % str(e), noiselevel=-1)
				del e
		elif (exitcode>0):
			print
			if exitcode==1:
				print darkred("!!!")+green(" Rsync has reported that there is a syntax error. Please ensure")
				print darkred("!!!")+green(" that your SYNC statement is proper.")
				print darkred("!!!")+green(" SYNC="+settings["SYNC"])
			elif exitcode==11:
				print darkred("!!!")+green(" Rsync has reported that there is a File IO error. Normally")
				print darkred("!!!")+green(" this means your disk is full, but can be caused by corruption")
				print darkred("!!!")+green(" on the filesystem that contains PORTDIR. Please investigate")
				print darkred("!!!")+green(" and try again after the problem has been fixed.")
				print darkred("!!!")+green(" PORTDIR="+settings["PORTDIR"])
			elif exitcode==20:
				print darkred("!!!")+green(" Rsync was killed before it finished.")
			else:
				print darkred("!!!")+green(" Rsync has not successfully finished. It is recommended that you keep")
				print darkred("!!!")+green(" trying or that you use the 'emerge-webrsync' option if you are unable")
				print darkred("!!!")+green(" to use rsync due to firewall or other restrictions. This should be a")
				print darkred("!!!")+green(" temporary problem unless complications exist with your network")
				print darkred("!!!")+green(" (and possibly your system's filesystem) configuration.")
			print
			sys.exit(exitcode)
	elif syncuri[:6]=="cvs://":
		if not os.path.exists("/usr/bin/cvs"):
			print "!!! /usr/bin/cvs does not exist, so CVS support is disabled."
			print "!!! Type \"emerge dev-util/cvs\" to enable CVS support."
			sys.exit(1)
		cvsroot=syncuri[6:]
		cvsdir=os.path.dirname(myportdir)
		if not os.path.exists(myportdir+"/CVS"):
			#initial checkout
			print ">>> Starting initial cvs checkout with "+syncuri+"..."
			if os.path.exists(cvsdir+"/gentoo-x86"):
				print "!!! existing",cvsdir+"/gentoo-x86 directory; exiting."
				sys.exit(1)
			if portage.spawn("cd "+cvsdir+"; cvs -z0 -d "+cvsroot+" co -P gentoo-x86",settings,free=1):
				print "!!! cvs checkout error; exiting."
				sys.exit(1)
			if cvsdir!=myportdir:
				portage.movefile(cvsdir,settings["PORTDIR"])
			sys.exit(0)
		else:
			#cvs update
			print ">>> Starting cvs update with "+syncuri+"..."
			sys.exit(portage.spawn("cd "+myportdir+"; cvs -z0 -q update -dP",settings,free=1))
	else:
		print "!!! rsync setting: ",syncuri,"not recognized; exiting."
		sys.exit(1)

	if updatecache_flg and  \
		myaction != "metadata" and \
		"metadata-transfer" not in settings.features:
		updatecache_flg = False

	# Reload the whole config from scratch.
	settings, trees, mtimedb = load_emerge_config(trees=trees)
	portdb = trees[settings["ROOT"]]["porttree"].dbapi

	if os.path.exists(myportdir+"/metadata/cache") and updatecache_flg:
		action_metadata(settings, portdb, myopts)

	portage.global_updates(
		settings, trees, mtimedb["updates"])
	mtimedb.commit()
	# Reload the whole config from scratch.
	settings, trees, mtimedb = load_emerge_config(trees=trees)
	portdb = trees[settings["ROOT"]]["porttree"].dbapi

	mybestpv = portdb.xmatch("bestmatch-visible", "sys-apps/portage")
	mypvs = portage.best(
		trees[settings["ROOT"]]["vartree"].dbapi.match("sys-apps/portage"))

	chk_updated_cfg_files("/", settings.get("CONFIG_PROTECT","").split())

	if myaction != "metadata":
		if os.access(portage.USER_CONFIG_PATH + "/bin/post_sync", os.X_OK):
			try:
				portage.spawn(portage.USER_CONFIG_PATH + "/bin/post_sync " + dosyncuri, settings, free=1)
			except:
				print red(" * ")+bold("spawn failed of "+ portage.USER_CONFIG_PATH + "/bin/post_sync")

	if(mybestpv != mypvs) and not "--quiet" in myopts:
		print
		print red(" * ")+bold("An update to portage is available.")+" It is _highly_ recommended"
		print red(" * ")+"that you update portage now, before any other packages are updated."
		print red(" * ")+"Please run 'emerge portage' and then update "+bold("ALL")+" of your"
		print red(" * ")+"configuration files."
		print red(" * ")+"To update portage, run 'emerge portage'."
		print

def action_metadata(settings, portdb, myopts):
	portage.writemsg_stdout("\n>>> Updating Portage cache:      ")
	old_umask = os.umask(0002)
	cachedir = os.path.normpath(settings.depcachedir)
	if cachedir in ["/",    "/bin", "/dev",  "/etc",  "/home",
					"/lib", "/opt", "/proc", "/root", "/sbin",
					"/sys", "/tmp", "/usr",  "/var"]:
		print >> sys.stderr, "!!! PORTAGE_DEPCACHEDIR IS SET TO A PRIMARY " + \
			"ROOT DIRECTORY ON YOUR SYSTEM."
		print >> sys.stderr, \
			"!!! This is ALMOST CERTAINLY NOT what you want: '%s'" % cachedir
		sys.exit(73)
	if not os.path.exists(cachedir):
		os.mkdir(cachedir)

	ec = portage.eclass_cache.cache(portdb.porttree_root)
	myportdir = os.path.realpath(settings["PORTDIR"])
	cm = settings.load_best_module("portdbapi.metadbmodule")(
		myportdir, "metadata/cache", portage.auxdbkeys[:])

	import cache.util

	class percentage_noise_maker(cache.util.quiet_mirroring):
		def __init__(self, dbapi):
			self.dbapi = dbapi
			self.cp_all = dbapi.cp_all()
			l = len(self.cp_all)
			self.call_update_min = 100000000
			self.min_cp_all = l/100.0
			self.count = 1
			self.pstr = ''

		def __iter__(self):
			for x in self.cp_all:
				self.count += 1
				if self.count > self.min_cp_all:
					self.call_update_min = 0
					self.count = 0
				for y in self.dbapi.cp_list(x):
					yield y
			self.call_update_mine = 0

		def update(self, *arg):
			try:				self.pstr = int(self.pstr) + 1
			except ValueError:	self.pstr = 1
			sys.stdout.write("%s%i%%" % \
				("\b" * (len(str(self.pstr))+1), self.pstr))
			sys.stdout.flush()
			self.call_update_min = 10000000

		def finish(self, *arg):
			sys.stdout.write("\b\b\b\b100%\n")
			sys.stdout.flush()

	if "--quiet" in myopts:
		def quicky_cpv_generator(cp_all_list):
			for x in cp_all_list:
				for y in portdb.cp_list(x):
					yield y
		source = quicky_cpv_generator(portdb.cp_all())
		noise_maker = cache.util.quiet_mirroring()
	else:
		noise_maker = source = percentage_noise_maker(portdb)
	cache.util.mirror_cache(source, cm, portdb.auxdb[myportdir],
		eclass_cache=ec, verbose_instance=noise_maker)

	sys.stdout.flush()
	os.umask(old_umask)

def action_regen(settings, portdb):
	xterm_titles = "notitles" not in settings.features
	emergelog(xterm_titles, " === regen")
	#regenerate cache entries
	print "Regenerating cache entries... "
	try:
		os.close(sys.stdin.fileno())
	except SystemExit, e:
		raise # Needed else can't exit
	except:
		pass
	sys.stdout.flush()
	mynodes = portdb.cp_all()
	for x in mynodes:
		mymatches = portdb.xmatch("match-all",x)
		portage.writemsg_stdout("processing %s\n" % x)
		for y in mymatches:
			try:
				foo = portdb.aux_get(y,["DEPEND"])
			except SystemExit, e:
				# sys.exit is an exception... And consequently, we can't catch it.
				raise
			except Exception, e:
				print "\n  error processing %(cpv)s, continuing... (%(e)s)" % {"cpv":y,"e":str(e)}
	print "done!"

def action_config(settings, trees, myopts, myfiles):
	if len(myfiles) != 1 or "system" in myfiles or "world" in myfiles:
		print red("!!! config can only take a single package atom at this time\n")
		sys.exit(1)
	if not is_valid_package_atom(myfiles[0]):
		portage.writemsg("!!! '%s' is not a valid package atom.\n" % myfiles[0],
			noiselevel=-1)
		portage.writemsg("!!! Please check ebuild(5) for full details.\n")
		portage.writemsg("!!! (Did you specify a version but forget to prefix with '='?)\n")
		sys.exit(1)
	print
	try:
		pkgs = trees[settings["ROOT"]]["vartree"].dbapi.match(myfiles[0])
	except ValueError, e:
		# Multiple matches thrown from cpv_expand
		pkgs = e.args[0]
	if len(pkgs) == 0:
		print "No packages found.\n"
		sys.exit(0)
	elif len(pkgs) > 1:
		if "--ask" in myopts:
			options = []
			print "Please select a package to configure:"
			idx = 0
			for pkg in pkgs:
				idx += 1
				options.append(str(idx))
				print options[-1]+") "+pkg
			print "X) Cancel"
			options.append("X")
			idx = userquery("Selection?", options)
			if idx == "X":
				sys.exit(0)
			pkg = pkgs[int(idx)-1]
		else:
			print "The following packages available:"
			for pkg in pkgs:
				print "* "+pkg
			print "\nPlease use a specific atom or the --ask option."
			sys.exit(1)
	else:
		pkg = pkgs[0]

	print
	if "--ask" in myopts:
		if userquery("Ready to configure "+pkg+"?") == "No":
			sys.exit(0)
	else:
		print "Configuring pkg..."
	print
	ebuildpath = trees[settings["ROOT"]]["vartree"].dbapi.findname(pkg)
	mysettings = portage.config(clone=settings)
	portage.doebuild(ebuildpath, "config", settings["ROOT"], mysettings,
		debug=(settings.get("PORTAGE_DEBUG", "") == 1), cleanup=True,
		mydbapi=trees[settings["ROOT"]]["vartree"].dbapi, tree="vartree")
	print

def action_info(settings, trees, myopts, myfiles):
	unameout=commands.getstatusoutput("uname -mrp")[1]
	print getportageversion(settings["PORTDIR"], settings["ROOT"],
		settings.profile_path, settings["CHOST"],
		trees[settings["ROOT"]]["vartree"].dbapi)
	header_width = 65
	header_title = "System Settings"
	if myfiles:
		print header_width * "="
		print header_title.rjust(int(header_width/2 + len(header_title)/2))
	print header_width * "="
	print "System uname: "+unameout
	if os.path.exists("/etc/gentoo-release"):
		os.system("cat /etc/gentoo-release")
	else:
		print "Unknown Host Operating System"
	lastSync = portage.grabfile(os.path.join(
		settings["PORTDIR"], "metadata", "timestamp.chk"))
	print "Last Sync:",
	if lastSync:
		print lastSync[0]
	else:
		print "Unknown"

	output=commands.getstatusoutput("distcc --version")
	if not output[0]:
		print str(string.split(output[1],"\n",1)[0]),
		if "distcc" in settings.features:
			print "[enabled]"
		else:
			print "[disabled]"

	output=commands.getstatusoutput("ccache -V")
	if not output[0]:
		print str(string.split(output[1],"\n",1)[0]),
		if "ccache" in settings.features:
			print "[enabled]"
		else:
			print "[disabled]"

	myvars  = ["sys-devel/autoconf", "sys-devel/automake", "virtual/os-headers",
	           "sys-devel/binutils", "sys-devel/libtool",  "dev-lang/python"]
	myvars += portage_util.grabfile(settings["PORTDIR"]+"/profiles/info_pkgs")
	myvars  = portage_util.unique_array(myvars)
	myvars.sort()

	for x in myvars:
		if portage.isvalidatom(x):
			pkg_matches = trees["/"]["vartree"].dbapi.match(x)
			pkgs = []
			for y in pkg_matches:
				mycpv   = portage.catpkgsplit(y)
				if(mycpv[3] != "r0"):
					pkgs += [mycpv[2] + "-" + mycpv[3]]
				else:
					pkgs += [mycpv[2]]
			if not pkgs:
				pkgs = "[Not Present]"
			else:
				pkgs = ", ".join(sorted_versions(pkgs))
			print "%-20s %s" % (x+":", pkgs)
		else:
			print "%-20s %s" % (x+":", "[NOT VALID]")

	libtool_vers = string.join(trees["/"]["vartree"].dbapi.match("sys-devel/libtool"), ",")

	if "--verbose" in myopts:
		myvars=settings.keys()
	else:
		myvars = ['GENTOO_MIRRORS', 'CONFIG_PROTECT', 'CONFIG_PROTECT_MASK',
		          'PORTDIR', 'DISTDIR', 'PKGDIR', 'PORTAGE_TMPDIR',
		          'PORTDIR_OVERLAY', 'USE', 'CHOST', 'CFLAGS', 'CXXFLAGS',
		          'ACCEPT_KEYWORDS', 'SYNC', 'FEATURES', 'EMERGE_DEFAULT_OPTS']

		myvars.extend(portage_util.grabfile(settings["PORTDIR"]+"/profiles/info_vars"))

	myvars = portage_util.unique_array(myvars)
	unset_vars = []
	myvars.sort()
	for x in myvars:
		if settings.has_key(x):
			print x+'="'+settings[x]+'"'
		else:
			unset_vars.append(x)
	if unset_vars:
		print "Unset:  "+", ".join(unset_vars)
	print

	if "--debug" in myopts:
		for x in dir(portage):
			module = getattr(portage, x)
			if "cvs_id_string" in dir(module):
				print "%s: %s" % (str(x), str(module.cvs_id_string))

	# See if we can find any packages installed matching the strings
	# passed on the command line
	mypkgs = []
	vardb = trees[settings["ROOT"]]["vartree"].dbapi
	for x in myfiles:
		mypkgs.extend(vardb.match(x))

	# If some packages were found...
	if mypkgs:
		# Get our global settings (we only print stuff if it varies from
		# the current config)
		mydesiredvars = [ 'CHOST', 'CFLAGS', 'CXXFLAGS' ]
		auxkeys = mydesiredvars + [ "USE", "IUSE"]
		global_vals = {}
		pkgsettings = portage.config(clone=settings)

		for myvar in mydesiredvars:
			global_vals[myvar] = set(settings.get(myvar, "").split())

		# Loop through each package
		# Only print settings if they differ from global settings
		header_printed = False
		for pkg in mypkgs:
			# Get all package specific variables
			auxvalues = vardb.aux_get(pkg, auxkeys)
			valuesmap = {}
			for i in xrange(len(auxkeys)):
				valuesmap[auxkeys[i]] = set(auxvalues[i].split())
			diff_values = {}
			for myvar in mydesiredvars:
				# If the package variable doesn't match the
				# current global variable, something has changed
				# so set diff_found so we know to print
				if valuesmap[myvar] != global_vals[myvar]:
					diff_values[myvar] = valuesmap[myvar]
			valuesmap["USE"] = valuesmap["USE"].intersection(valuesmap["IUSE"])
			pkgsettings.reset()
			pkgsettings.setcpv(pkg)
			if valuesmap["IUSE"].intersection(pkgsettings["USE"].split()) != \
				valuesmap["USE"]:
				diff_values["USE"] = valuesmap["USE"]
			# If a difference was found, print the info for
			# this package.
			if diff_values:

				# If we have not yet printed the header, 
				# print it now
				if not header_printed:
					header_title = "Package Settings"
					print header_width * "="
					print header_title.rjust(int(header_width/2 + len(header_title)/2))
					print header_width * "="
					header_printed = True

				# Print package info
				print "%s was built with the following:" % pkg
				for myvar in mydesiredvars + ["USE"]:
					if myvar in diff_values:
						mylist = list(diff_values[myvar])
						mylist.sort()
						print "%s=\"%s\"" % (myvar, " ".join(mylist))
				print

def action_search(settings, portdb, vartree, myopts, myfiles, spinner):
	if not myfiles:
		print "emerge: no search terms provided."
	else:
		searchinstance = search(settings, portdb,
			vartree, spinner, "--searchdesc" in myopts,
			"--quiet" not in myopts)
		for mysearch in myfiles:
			try:
				searchinstance.execute(mysearch)
			except re.error, comment:
				print "\n!!! Regular expression error in \"%s\": %s" % ( mysearch, comment )
				sys.exit(1)
			searchinstance.output()

def action_depclean(settings, trees, ldpath_mtimes,
	myopts, spinner):
	# Kill packages that aren't explicitly merged or are required as a
	# dependency of another package. World file is explicit.

	warn_prefix = colorize("BAD", "*** WARNING ***  ")
	print
	print warn_prefix + "Depclean may break link level dependencies.  Thus, it is"
	print warn_prefix + "recommended to use a tool such as " + good("`revdep-rebuild`") + " (from"
	print warn_prefix + "app-portage/gentoolkit) in order to detect such breakage."
	print warn_prefix
	print warn_prefix + "Also study the list of packages to be cleaned for any obvious"
	print warn_prefix + "mistakes. Packages that are part of the world set will always"
	print warn_prefix + "be kept.  They can be manually added to this set with"
	print warn_prefix + good("`emerge --noreplace <atom>`") + "."
	print warn_prefix
	print warn_prefix + "As a safety measure, depclean will not remove any packages"
	print warn_prefix + "unless *all* required dependencies have been resolved.  As a"
	print warn_prefix + "consequence, it is often necessary to run "
	print warn_prefix + good("`emerge --update --deep world`") + " prior to depclean."

	xterm_titles = "notitles" not in settings.features
	portdb = trees[settings["ROOT"]]["porttree"].dbapi
	vartree = trees[settings["ROOT"]]["vartree"]
	vardb = vartree.dbapi
	syslist = getlist(settings, "system")
	worldlist = getlist(settings, "world")
	fakedb = portage.fakedbapi(settings=settings)
	emptydb = portage.fakedbapi(settings=settings)
	myvarlist = vardb.cpv_all()

	if not syslist:
		print "\n!!! You have no system list.",
	if not worldlist:
		print "\n!!! You have no world file.",
	if not myvarlist:
		print "\n!!! You have no installed package database (%s)." % portage.VDB_PATH,

	if not (syslist and worldlist and myvarlist):
		print "\n!!! Proceeding "+(syslist and myvarlist and "may" or "will")
		print " break your installation.\n"
		if "--pretend" not in myopts:
			countdown(int(settings["EMERGE_WARNING_DELAY"]), ">>> Depclean")

	if not "--pretend" in myopts: #just check pretend, since --ask implies pretend
		emergelog(xterm_titles, " >>> depclean")

	if "--quiet" not in myopts:
		print "\nCalculating dependencies  ",

	remaining_atoms = [(atom, 'world') for atom in worldlist if vardb.match(atom)]
	remaining_atoms += [(atom, 'system') for atom in syslist if vardb.match(atom)]
	unresolveable = {}

	while remaining_atoms:
		atom, parent = remaining_atoms.pop()
		pkgs = vardb.match(atom)
		if not pkgs:
			if not atom.startswith("!"):
				if atom in unresolveable:
					unresolveable[atom].append(parent)
				else:
					unresolveable[atom] = [parent]
			continue
		# Could put slot checking here to ensure that there aren't two
		# packages with the same slot...
		for pkg in pkgs:
			if fakedb.cpv_exists(pkg):
				continue
			spinner.update()
			fakedb.cpv_inject(pkg)
			mydb = portdb.xmatch("match-visible", "="+pkg) and portdb or vardb
			depstr = " ".join(mydb.aux_get(pkg,
				["DEPEND", "RDEPEND", "PDEPEND"]))
			usedef = vardb.aux_get(pkg, ["USE"])[0].split()
			success, atoms = portage.dep_check(depstr, emptydb, settings,
				myuse=usedef, trees=trees, myroot=settings["ROOT"])
			if not success:
				print "\n\n"
				print "Error occurred while processing",pkg
				print str(atoms)
				return
			for atom in atoms:
				remaining_atoms.append((atom, pkg))

	if "--quiet" not in myopts:
		print "\b\b... done!\n"

	if unresolveable:
		print "Dependencies could not be completely resolved due to"
		print "the following required packages not being installed:"
		print
		for atom in unresolveable:
			print atom, "required by", " ".join(unresolveable[atom])
		print
		print "Have you forgotten to run " + good("`emerge --update --deep world`") + " prior to depclean?"
		print
		return

	cleanlist = [pkg for pkg in vardb.cpv_all() if not fakedb.cpv_exists(pkg)]

	if len(cleanlist):
		unmerge(settings, myopts, vartree, "unmerge", cleanlist, ldpath_mtimes)

	print "Packages installed:   "+str(len(myvarlist))
	print "Packages in world:    "+str(len(worldlist))
	print "Packages in system:   "+str(len(syslist))
	print "Unique package names: "+str(len(myvarlist))
	print "Required packages:    "+str(len(fakedb.cpv_all()))
	if "--pretend" in myopts:
		print "Number to remove:     "+str(len(cleanlist))
	else:
		print "Number removed:       "+str(len(cleanlist))

def action_build(settings, trees, mtimedb,
	myopts, myaction, myfiles, spinner):
	ldpath_mtimes = mtimedb["ldpath"]
	favorites=[]
	if ("--ask" in myopts or "--pretend" in myopts) and not "--quiet" in myopts:
		action = ""
		if "--fetchonly" in myopts or "--fetch-all-uri" in myopts:
			action = "fetched"
		else:
			action = "merged"
		if "--tree" in myopts and action != "fetched": # Tree doesn't work with fetching
			print
			print darkgreen("These are the packages that would be %s, in reverse order:") % action
			print
		else:
			print
			print darkgreen("These are the packages that would be %s, in order:") % action
			print

	# validate the state of the resume data
	# so that we can make assumptions later.
	for k in ("resume", "resume_backup"):
		if k in mtimedb:
			if "mergelist" in mtimedb[k]:
				if not mtimedb[k]["mergelist"]:
					del mtimedb[k]
			else:
				del mtimedb[k]

	if "--resume" in myopts and \
		("resume" in mtimedb or
		"resume_backup" in mtimedb):
		if "resume" not in mtimedb:
			mtimedb["resume"] = mtimedb["resume_backup"]
			del mtimedb["resume_backup"]
			mtimedb.commit()
		myresumeopts=mtimedb["resume"]["myopts"][:]

		for opt in ("--skipfirst", "--ask", "--tree"):
			while opt in myresumeopts:
				myresumeopts.remove(opt)

		for myopt in myopts:
			if myopt not in myresumeopts:
				myresumeopts.append(myopt)
		myopts=myresumeopts
		myparams = create_depgraph_params(myopts, myaction)
		mydepgraph = depgraph(settings, trees,
			myopts, myparams, spinner)
		if "--resume" not in myopts:
			myopts+=["--resume"]
	else:
		if ("--resume" in myopts):
			del myopts[myopts.index("--resume")]
			print darkgreen("emerge: It seems we have nothing to resume...")
			sys.exit(0)

		myparams = create_depgraph_params(myopts, myaction)
		mydepgraph = depgraph(settings, trees,
			myopts, myparams, spinner)
		if myaction in ["system","world"]:
			if not ("--quiet" in myopts):
				print "Calculating",myaction,"dependencies  ",
				sys.stdout.flush()
			if not mydepgraph.xcreate(myaction):
				print "!!! Depgraph creation failed."
				sys.exit(1)
			if not ("--quiet" in myopts):
				print "\b\b... done!"
		else:
			if not ("--quiet" in myopts):
				print "Calculating dependencies  ",
				sys.stdout.flush()
			try:
				retval, favorites = mydepgraph.select_files(myfiles)
			except portage_exception.PackageNotFound, e:
				portage.writemsg("\n!!! %s\n" % str(e), noiselevel=-1)
				sys.exit(1)
			if not retval:
				sys.exit(1)
			if not ("--quiet" in myopts):
				print "\b\b... done!"

			if ("--usepkgonly" in myopts) and mydepgraph.missingbins:
				sys.stderr.write(red("The following binaries are not available for merging...\n"))

		if mydepgraph.missingbins:
			for x in mydepgraph.missingbins:
				sys.stderr.write("   "+str(x)+"\n")
			sys.stderr.write("\nThese are required by '--usepkgonly' -- Terminating.\n\n")
			sys.exit(1)

	if "--ask" in myopts:
		if "--resume" in myopts:
			validate_merge_list(trees, mtimedb["resume"]["mergelist"])
			mymergelist = mtimedb["resume"]["mergelist"]
			if "--skipfirst" in myopts:
				mymergelist = mymergelist[1:]
			if len(mymergelist) == 0:
				print colorize("INFORM", "emerge: It seems we have nothing to resume...")
				sys.exit(0)
			mydepgraph.display(mymergelist)
			prompt="Would you like to resume merging these packages?"
		else:
			mydepgraph.display(
				mydepgraph.altlist(reversed=("--tree" in myopts)))
			mergecount=0
			for x in mydepgraph.altlist():
				if x[0] != "blocks" and x[3] != "nomerge":
					mergecount+=1
				#check for blocking dependencies
				if x[0]=="blocks" and "--fetchonly" not in myopts and "--fetch-all-uri" not in myopts:
					print "\n!!! Error: The above package list contains packages which cannot be installed"
					print   "!!!        at the same time on the same system."
					if "--quiet" not in myopts:
						show_blocker_docs_link()
					sys.exit(1)
			if mergecount==0:
				if settings["AUTOCLEAN"] and "yes"==settings["AUTOCLEAN"]:
					prompt="Nothing to merge; would you like to auto-clean packages?"
				else:
					print
					print "Nothing to merge; quitting."
					print
					sys.exit(0)
			elif "--fetchonly" in myopts or "--fetch-all-uri" in myopts:
				prompt="Would you like to fetch the source files for these packages?"
			else:
				prompt="Would you like to merge these packages?"
		print
		if userquery(prompt)=="No":
			print
			print "Quitting."
			print
			sys.exit(0)
		# Don't ask again (e.g. when auto-cleaning packages after merge)
		myopts.remove("--ask")

	if ("--pretend" in myopts) and not ("--fetchonly" in myopts or "--fetch-all-uri" in myopts):
		if ("--resume" in myopts):
			validate_merge_list(trees, mtimedb["resume"]["mergelist"])
			mymergelist = mtimedb["resume"]["mergelist"]
			if "--skipfirst" in myopts:
				mymergelist = mymergelist[1:]
			if len(mymergelist) == 0:
				print colorize("INFORM", "emerge: It seems we have nothing to resume...")
				sys.exit(0)
			mydepgraph.display(mymergelist)
		else:
			mydepgraph.display(
				mydepgraph.altlist(reversed=("--tree" in myopts)))
	else:
		if ("--buildpkgonly" in myopts):
			if not mydepgraph.digraph.hasallzeros(ignore_soft_deps=True):
				print "\n!!! --buildpkgonly requires all dependencies to be merged."
				print "!!! Cannot merge requested packages. Merge deps and try again.\n"
				sys.exit(1)

		if ("--resume" in myopts):
			favorites=mtimedb["resume"]["favorites"]
			mergetask = MergeTask(settings, trees, myopts)
			if "--fetchonly" in myopts:
				""" parallel-fetch uses --resume --fetchonly and we don't want
				it to write the mtimedb"""
				mtimedb.filename = None
				time.sleep(3) # allow the parent to have first fetch
			mergetask.merge(mtimedb["resume"]["mergelist"], favorites, mtimedb)
		else:
			if "resume" in mtimedb and \
			"mergelist" in mtimedb["resume"] and \
			len(mtimedb["resume"]["mergelist"]) > 1:
				mtimedb["resume_backup"] = mtimedb["resume"]
				del mtimedb["resume"]
				mtimedb.commit()
			mtimedb["resume"]={}
			mtimedb["resume"]["myopts"]=myopts
			mtimedb["resume"]["favorites"]=favorites
			if ("--digest" in myopts) and not ("--fetchonly" in myopts or "--fetch-all-uri" in myopts):
				for pkgline in mydepgraph.altlist():
					if pkgline[0]=="ebuild" and pkgline[3]=="merge":
						y = trees[pkgline[1]]["porttree"].dbapi.findname(pkgline[2])
						tmpsettings = portage.config(clone=settings)
						edebug = 0
						if settings.get("PORTAGE_DEBUG", "") == "1":
							edebug = 1
						retval = portage.doebuild(
							y, "digest", settings["ROOT"], tmpsettings, edebug,
							("--pretend" in myopts),
							mydbapi=trees[pkgline[1]]["porttree"].dbapi,
							tree="porttree")
			if "--fetchonly" in myopts or "--fetch-all-uri" in myopts:
				pkglist = []
				for pkg in mydepgraph.altlist():
					if pkg[0] != "blocks":
						pkglist.append(pkg)
			else:
				pkglist = mydepgraph.altlist()
			mergetask = MergeTask(settings, trees, myopts)
			mergetask.merge(pkglist, favorites, mtimedb)

		if mtimedb.has_key("resume"):
			del mtimedb["resume"]
		if settings["AUTOCLEAN"] and "yes"==settings["AUTOCLEAN"]:
			print ">>> Auto-cleaning packages..."
			vartree = trees[settings["ROOT"]]["vartree"]
			unmerge(settings, myopts, vartree, "clean", ["world"],
				ldpath_mtimes)
		else:
			portage.writemsg_stdout(colorize("WARN", "WARNING:")
				+ " AUTOCLEAN is disabled.  This can cause serious"
				+ " problems due to overlapping packages.\n")

def parse_opts(tmpcmdline):
	myaction=None
	myopts=[]
	myfiles=[]

	cmdline=[]
	for x in tmpcmdline:
		if x[0:1]=="-" and x[1:2]!="-":
			for y in x[1:]:
				if shortmapping.has_key(y):
					if shortmapping[y] in cmdline:
						if not shortmapping[y] in ("--verbose", "--pretend"):
							print
							print "*** Warning: Redundant use of",shortmapping[y]
					else:
						cmdline.append(shortmapping[y])
				else:
					print "!!! Error: -"+y+" is an invalid short action or option."
					sys.exit(1)
		else:
			cmdline.append(x)

	# process the options and command arguments
	for x in cmdline:
		if not x:
			continue
		if len(x)>=2 and x[0:2]=="--":
			if x == "--cols":
				x = "--columns"
			elif x == "--skip-first":
				x = "--skipfirst"
			if x in options:
				if x not in myopts:
					myopts.append(x)
			elif x[2:] in actions:
				if myaction:
					if myaction not in ["system", "world"]:
						myaction="--"+myaction
					print
					print red("!!!")+green(" Multiple actions requested... Please choose one only.")
					print red("!!!")+" '"+darkgreen(myaction)+"' "+red("or")+" '"+darkgreen(x)+"'"
					print
					sys.exit(1)
				myaction=x[2:]
			else:
				print "!!! Error:",x,"is an invalid option."
				sys.exit(1)
		elif (not myaction) and (x in actions):
			if x not in ["system", "world"]:
				print red("*** Deprecated use of action '%s', use '--%s' instead" % (x,x))
			if myaction:
				print
				print red("!!!")+green(" Multiple actions requested... Please choose one only.")
				print red("!!! '")+darkgreen(myaction)+"' "+red("or")+" '"+darkgreen(x)+"'"
				print
				sys.exit(1)
			myaction=x
		elif x[-1]=="/":
			# this little conditional helps tab completion
			myfiles.append(x[:-1])
		else:
			myfiles.append(x)

	return myaction, myopts, myfiles

def validate_ebuild_environment(trees):
	for myroot in trees:
		mysettings = trees[myroot]["vartree"].settings
		if not mysettings.get("ARCH", None):
			print >> sys.stderr, bad("\a!!! ARCH is not set... " + \
				"Are you missing the '%setc/make.profile' symlink?" % \
				mysettings["PORTAGE_CONFIGROOT"])
			print >> sys.stderr, bad("\a!!! Is the symlink correct? " + \
				"Is your portage tree complete?\n")
			sys.exit(9)
		del myroot, mysettings

def load_emerge_config(trees=None):
	kwargs = {}
	for k, envvar in (("config_root", "PORTAGE_CONFIGROOT"), ("target_root", "ROOT")):
		kwargs[k] = os.environ.get(envvar, "/")
	trees = portage.create_trees(trees=trees, **kwargs)

	settings = trees["/"]["vartree"].settings

	for myroot in trees:
		if myroot != "/":
			settings = trees[myroot]["vartree"].settings
			break

	mtimedbfile = os.path.join("/", portage.CACHE_PATH.lstrip(os.path.sep), "mtimedb")
	mtimedb = portage.MtimeDB(mtimedbfile)
	return settings, trees, mtimedb

def adjust_config(myopts, settings):
	"""Make emerge specific adjustments to the config."""

	# To enhance usability, make some vars case insensitive by forcing them to
	# lower case.
	for myvar in ("AUTOCLEAN", "NOCOLOR"):
		if myvar in settings:
			settings[myvar] = settings[myvar].lower()
			settings.backup_changes(myvar)
	del myvar

	# Kill noauto as it will break merges otherwise.
	if "noauto" in settings.features:
		while "noauto" in settings.features:
			settings.features.remove("noauto")
		settings["FEATURES"] = " ".join(settings.features)
		settings.backup_changes("FEATURES")

	CLEAN_DELAY = 5
	try:
		CLEAN_DELAY = int(settings.get("CLEAN_DELAY", str(CLEAN_DELAY)))
	except ValueError, e:
		portage.writemsg("!!! %s\n" % str(e), noiselevel=-1)
		portage.writemsg("!!! Unable to parse integer: CLEAN_DELAY='%s'\n" % \
			settings["CLEAN_DELAY"], noiselevel=-1)
	settings["CLEAN_DELAY"] = str(CLEAN_DELAY)
	settings.backup_changes("CLEAN_DELAY")

	EMERGE_WARNING_DELAY = 10
	try:
		EMERGE_WARNING_DELAY = int(settings.get(
			"EMERGE_WARNING_DELAY", str(EMERGE_WARNING_DELAY)))
	except ValueError, e:
		portage.writemsg("!!! %s\n" % str(e), noiselevel=-1)
		portage.writemsg("!!! Unable to parse integer: EMERGE_WARNING_DELAY='%s'\n" % \
			settings["EMERGE_WARNING_DELAY"], noiselevel=-1)
	settings["EMERGE_WARNING_DELAY"] = str(EMERGE_WARNING_DELAY)
	settings.backup_changes("EMERGE_WARNING_DELAY")

	if "--quiet" in myopts:
		settings["PORTAGE_QUIET"]="1"
		settings.backup_changes("PORTAGE_QUIET")

	# Set so that configs will be merged regardless of remembered status
	if ("--noconfmem" in myopts):
		settings["NOCONFMEM"]="1"
		settings.backup_changes("NOCONFMEM")

	# Set various debug markers... They should be merged somehow.
	PORTAGE_DEBUG = 0
	try:
		PORTAGE_DEBUG = int(settings.get("PORTAGE_DEBUG", str(PORTAGE_DEBUG)))
		if PORTAGE_DEBUG not in (0, 1):
			portage.writemsg("!!! Invalid value: PORTAGE_DEBUG='%i'\n" % \
				PORTAGE_DEBUG, noiselevel=-1)
			portage.writemsg("!!! PORTAGE_DEBUG must be either 0 or 1\n",
				noiselevel=-1)
			PORTAGE_DEBUG = 0
	except ValueError, e:
		portage.writemsg("!!! %s\n" % str(e), noiselevel=-1)
		portage.writemsg("!!! Unable to parse integer: PORTAGE_DEBUG='%s'\n" %\
			settings["PORTAGE_DEBUG"], noiselevel=-1)
		del e
	if "--debug" in myopts:
		PORTAGE_DEBUG = 1
	settings["PORTAGE_DEBUG"] = str(PORTAGE_DEBUG)
	settings.backup_changes("PORTAGE_DEBUG")

	# Set color output
	if "--nocolor" in myopts:
		settings["NOCOLOR"] = "true"
		settings.backup_changes("NOCOLOR")

def emerge_main():
	# Portage needs to ensure a sane umask for the files it creates.
	os.umask(022)
	settings, trees, mtimedb = load_emerge_config()
	portdb = trees[settings["ROOT"]]["porttree"].dbapi
	portage.global_updates(settings, trees, mtimedb["updates"])
	mtimedb.commit()
	# Reload the whole config from scratch.
	settings, trees, mtimedb = load_emerge_config(trees=trees)
	portdb = trees[settings["ROOT"]]["porttree"].dbapi

	ldpath_mtimes = mtimedb["ldpath"]
	xterm_titles = "notitles" not in settings.features

	if settings.get("NOCOLOR","").lower() in ("yes","true"):
		nocolor()
	elif (not sys.stdout.isatty()) and \
		settings.get("NOCOLOR","").lower() != "no":
		# revdep-rebuild exports NOCOLOR=false, so for now, don't allow
		# NOCOLOR=false to override the isatty() check.  This can be fixed
		# in revdep-rebuild by using the --nocolor option when appropriate
		# instead of exporting NOCOLOR.
		nocolor()

	tmpcmdline = sys.argv[1:]
	if "--ignore-default-opts" not in tmpcmdline:
		tmpcmdline.extend(settings["EMERGE_DEFAULT_OPTS"].split())
	myaction, myopts, myfiles = parse_opts(tmpcmdline)

	for myroot in trees:
		mysettings =  trees[myroot]["vartree"].settings
		mysettings.unlock()
		adjust_config(myopts, mysettings)
		mysettings.lock()
		del myroot, mysettings

	spinner = stdout_spinner()
	if "candy" in settings.features:
		spinner.update = spinner.update_scroll

	portage.deprecated_profile_check()

	try:
		os.nice(int(settings.get("PORTAGE_NICENESS", "0")))
	except (OSError, ValueError), e:
		portage.writemsg("!!! Failed to change nice value to '%s'\n" % \
			settings["PORTAGE_NICENESS"])
		portage.writemsg("!!! %s\n" % str(e))
		del e

	#Freeze the portdbapi for enhanced performance:
	for myroot in trees:
		trees[myroot]["porttree"].dbapi.freeze()
		del myroot

	if "moo" in myfiles:
		print """

  Larry loves Gentoo (""" + os.uname()[0] + """)

 _______________________
< Have you mooed today? >
 -----------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\ 
                ||----w |
                ||     ||

"""

	if (myaction in ["world", "system"]) and myfiles:
		print "emerge: please specify a package class (\"world\" or \"system\") or individual packages, but not both."
		sys.exit(1)

	for x in myfiles:
		ext = os.path.splitext(x)[1]
		if (ext == ".ebuild" or ext == ".tbz2") and os.path.exists(os.path.abspath(x)):
			print "emerging by path implies --oneshot... adding --oneshot to options."
			print colorize("BAD", "\n*** emerging by path is broken and may not always work!!!\n")
			break

	if ("--tree" in myopts) and ("--columns" in myopts):
		print "emerge: can't specify both of \"--tree\" and \"--columns\"."
		sys.exit(1)

	if ("--quiet" in myopts):
		spinner.update = spinner.update_quiet
		portage_util.noiselimit = -1

	# Always create packages if FEATURES=buildpkg
	# Imply --buildpkg if --buildpkgonly
	if ("buildpkg" in settings.features) or ("--buildpkgonly" in myopts):
		if "--buildpkg" not in myopts:
			myopts.append("--buildpkg")

	# --tree only makes sense with --pretend
	if "--tree" in myopts and not (("--pretend" in myopts) or ("--ask" in myopts)):
		print ">>> --tree implies --pretend... adding --pretend to options."
		myopts.append("--pretend")

	# Also allow -S to invoke search action (-sS)
	if ("--searchdesc" in myopts):
		if myaction and myaction != "search":
			myfiles.append(myaction)
		if "--search" not in myopts:
			myopts.append("--search")
		myaction = "search"

	# Always try and fetch binary packages if FEATURES=getbinpkg
	if ("getbinpkg" in settings.features):
		myopts.append("--getbinpkg")

	if "--skipfirst" in myopts and "--resume" not in myopts:
		myopts.append("--resume")

	if ("--getbinpkgonly" in myopts) and not ("--usepkgonly" in myopts):
		myopts.append("--usepkgonly")

	if ("--getbinpkgonly" in myopts) and not ("--getbinpkg" in myopts):
		myopts.append("--getbinpkg")

	if ("--getbinpkg" in myopts) and not ("--usepkg" in myopts):
		myopts.append("--usepkg")

	# Also allow -K to apply --usepkg/-k
	if ("--usepkgonly" in myopts) and not ("--usepkg" in myopts):
		myopts.append("--usepkg")

	if ("--newuse" in myopts) and not ("--update" in myopts):
		print ">>> --newuse implies --update... adding --update to options."
		myopts.append("--update")

	# Also allow -l to apply --pretend/-p, but if already in --ask mode
	if ("--changelog" in myopts) and not (("--pretend" in myopts) or ("--ask" in myopts)):
		print ">>> --changelog implies --pretend... adding --pretend to options."
		myopts.append("--pretend")

	# Allow -p to remove --ask
	if ("--pretend" in myopts) and ("--ask" in myopts):
		print ">>> --pretend disables --ask... removing --ask from options."
		myopts.remove("--ask")

	# forbid --ask when not in a terminal
	# note: this breaks `emerge --ask | tee logfile`, but that doesn't work anyway.
	if ("--ask" in myopts) and (not sys.stdin.isatty()):
		portage.writemsg("!!! \"--ask\" should only be used in a terminal. Exiting.\n",
			noiselevel=-1)
		sys.exit(1)

	if settings.get("PORTAGE_DEBUG", "") == "1":
		portage.debug=1
		if "python-trace" in settings.features:
			import portage_debug
			portage_debug.set_trace(True)

	if ("--resume" in myopts):
		if "--tree" in myopts:
			print "* --tree is currently broken with --resume. Disabling..."
			myopts.remove("--tree")

	# Set color output
	if "--nocolor" in myopts or \
	settings["NOCOLOR"] in ("yes","true"):
		nocolor()

	if not ("--quiet" in myopts):
		if not sys.stdout.isatty() or ("--nospinner" in myopts):
			spinner.update = spinner.update_basic

	if "--version" in myopts:
		print getportageversion(settings["PORTDIR"], settings["ROOT"],
			settings.profile_path, settings["CHOST"],
			trees[settings["ROOT"]]["vartree"].dbapi)
		sys.exit(0)
	elif "--help" in myopts:
		emergehelp.help(myaction, myopts, havecolor)
		sys.exit(0)

	if portage.wheelgid == portage.portage_gid:
		print "emerge: wheel group use is being deprecated. Please update group and passwd to"
		print "        include the portage user as noted above, and then use group portage."

	if "--debug" in myopts:
		print "myaction", myaction
		print "myopts", myopts

	if not myaction and not myfiles and "--resume" not in myopts:
		emergehelp.help(myaction, myopts, havecolor)
		sys.exit(1)

	# check if root user is the current user for the actions where emerge needs this
	if portage.secpass < 2:
		# We've already allowed "--version" and "--help" above.
		if "--pretend" not in myopts and \
		myaction not in ("search","info"):
			if portage.secpass >= 1:
				if "--fetchonly" not in myopts and \
				"--fetch-all-uri" not in myopts and \
				myaction not in ("metadata", "regen"):
					print "emerge: root access required."
					sys.exit(1)
			else:
				print "emerge: root access required."
				sys.exit(1)

	disable_emergelog = False
	for x in ("--pretend", "--fetchonly", "--fetch-all-uri"):
		if x in myopts:
			disable_emergelog = True
			break
	if myaction in ("search", "info"):
		disable_emergelog = True
	if disable_emergelog:
		""" Disable emergelog for everything except build or unmerge
		operations.  This helps minimize parallel emerge.log entries that can
		confuse log parsers.  We especially want it disabled during
		parallel-fetch, which uses --resume --fetchonly."""
		global emergelog
		def emergelog(*pargs, **kargs):
			pass

	if not "--pretend" in myopts:
		emergelog(xterm_titles, "Started emerge on: "+\
			time.strftime("%b %d, %Y %H:%M:%S", time.localtime()))
		myelogstr=""
		if myopts:
			myelogstr=string.join(myopts, " ")
		if myaction:
			myelogstr+=" "+myaction
		if myfiles:
			myelogstr+=" "+string.join(myfiles, " ")
		emergelog(xterm_titles, " *** emerge " + myelogstr)

	def emergeexitsig(signum, frame):
		signal.signal(signal.SIGINT, signal.SIG_IGN)
		signal.signal(signal.SIGTERM, signal.SIG_IGN)
		portage_util.writemsg("\n\nExiting on signal %(signal)s\n" % {"signal":signum})
		sys.exit(100+signum)
	signal.signal(signal.SIGINT, emergeexitsig)
	signal.signal(signal.SIGTERM, emergeexitsig)

	def emergeexit():
		"""This gets out final log message in before we quit."""
		if "--pretend" not in myopts:
			emergelog(xterm_titles, " *** terminating.")
		if "notitles" not in settings.features:
			xtermTitleReset()
	portage.atexit_register(emergeexit)

	if myaction in ["sync","metadata"] and "--help" not in myopts:
		if "--pretend" in myopts:
			print "emerge: \"sync\" actions do not support \"--pretend.\""
			sys.exit(1)
		if "sync" == myaction:
			action_sync(settings, trees, mtimedb, myopts, myaction)
		else:
			action_metadata(settings, portdb, myopts)
	elif myaction=="regen":
		validate_ebuild_environment(trees)
		action_regen(settings, portdb)
	# HELP action
	elif "config"==myaction:
		validate_ebuild_environment(trees)
		action_config(settings, trees, myopts, myfiles)
	
	# INFO action
	elif "info"==myaction:
		action_info(settings, trees, myopts, myfiles)

	# SEARCH action
	elif "search"==myaction:
		validate_ebuild_environment(trees)
		action_search(settings, portdb, trees["/"]["vartree"],
			myopts, myfiles, spinner)
	elif "unmerge"==myaction or "prune"==myaction or "clean"==myaction:
		validate_ebuild_environment(trees)
		vartree = trees[settings["ROOT"]]["vartree"]
		if 1 == unmerge(settings, myopts, vartree, myaction, myfiles,
			ldpath_mtimes, raise_on_missing=False):
			if "--pretend" not in myopts:
				post_emerge(settings, mtimedb, 0)

	elif "depclean"==myaction:
		validate_ebuild_environment(trees)
		action_depclean(settings, trees, ldpath_mtimes,
			myopts, spinner)
		if "--pretend" not in myopts:
			post_emerge(settings, mtimedb, 0)
	# "update", "system", or just process files:
	else:
		validate_ebuild_environment(trees)
		action_build(settings, trees, mtimedb,
			myopts, myaction, myfiles, spinner)
		if "--pretend" not in myopts:
			post_emerge(settings, mtimedb, 0)

if __name__ == "__main__":
	emerge_main()
