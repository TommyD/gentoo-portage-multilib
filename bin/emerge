#!/usr/bin/env python2.2
# Copyright 1999-2002 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License v2
# $Header$

import os,sys,portage,xpak,string,re,commands,time,threading,shutil,traceback
from stat import *
from output import *
if (not sys.stdout.isatty()) or (portage.settings["NOCOLOR"] in ["yes","true"]):
	nocolor()

spinner="\|/-\|/-"
spinpos=0
#number of ebuilds merged
merged=0
params=["selective", "deep", "self", "recurse", "empty"]
actions=["clean", "config", "help", "info", "prune", "rsync", "search", "sync", "system", "unmerge", "world", "inject", "regen", "depclean"]
options=["--autoclean", "--deep", "--selective", "--buildpkg", "--debug", "--nodeps", "--emptytree", "--fetchonly", 
"--noreplace", "--onlydeps", "--pretend", "--usepkg", "--usepkgonly", "--searchdesc", "--verbose", "--update", "--help", "--oneshot", "--version"]

shortmapping={"a":"--autoclean", "b":"--buildpkg", "c":"clean", "C":"unmerge", "e":"--emptytree", "d":"--debug", "f":"--fetchonly",
	"h":"--help", "k":"--usepkg", "K":"--usepkgonly", "n":"--noreplace", "o":"--onlydeps", "p":"--pretend", "P":"prune", "s":"search",
	"S":"--searchdesc",	"u":"--update", "v":"--verbose", "V":"--version", "i":"inject"}

def emergelog(mystr):
	try:
		mylogfile=open("/var/log/emerge.log", "a")
		mylogfile.write(str(time.time())[:10]+": "+mystr+"\n")
		mylogfile.flush()
		mylogfile.close()
	except Exception, e:
		if edebug:
			print "emergelog():",e
		pass

def countdown(secs=5, doing="Starting"):
	if secs:
		print ">>> Waiting",secs,"seconds before starting..."
		print ">>> (Control-C to abort)...\n"+doing+" in: ",
		ticks=range(secs)
		ticks.reverse()
		for sec in ticks:
			sys.stdout.write(red(str(sec+1)+" "))
			sys.stdout.flush()
			time.sleep(1)
		print

def getportageversion():
	try:
		profilever=string.split(os.readlink("/etc/make.profile"), "/")[-1]
	except:
		profilever="unavailable"
	glibcver=[]
	for x in portage.vardbapi(portage.root).match("glibc"):
		xs=portage.pkgsplit(x)
		if glibcver:
			glibcver+=","+xs[1]+"-"+xs[2]
		else:
			glibcver=xs[1]+"-"+xs[2]
	if glibcver==[]:
		glibcver="unavailable"

	gccver=commands.getstatusoutput("/usr/bin/gcc -dumpversion")[1]
	return "Portage " + portage.VERSION +" ("+profilever+", gcc-"+gccver+", glibc-"+glibcver+")"


def help():
	if not myaction:
		print
		print bold("Usage: ")+turquoise("emerge")+" [ "+green("options")+" ] [ "+green("action")+" ] [ "+turquoise("ebuildfile")+" | "+turquoise("tbz2file")+" | "+turquoise("dependency")+" ] ..."
		print "       "+turquoise("emerge")+" [ "+green("options")+" ] [ "+green("action")+" ] "+turquoise("system")
		print "       "+turquoise("emerge")+" "+turquoise("sync")+" | "+turquoise("rsync")
		print "       "+turquoise("emerge")+" "+green("--help")+" "" "+green("-h")+" [ "+turquoise("system")+" | "+turquoise("config")+" ] "
		print
		print turquoise("Help (this screen):")
		print "       "+green("--help")+" ("+green("-h")+" short option)"
		print "              Displays this help; an additional argument (see above) will tell"
		print "              emerge to display detailed help."
		print
		print turquoise("Actions:")
		print "       "+green("clean")+" ("+green("-c")+" short option)"
		print "              Cleans the system by removing outdated packages which will not"
		print "              remove functionalities or prevent your system from working."
		print "              The arguments can be in several different formats :"
		print "              * world "
		print "              * system "
		print "              * /var/db/pkg/category/package-version, or"
		print "              * 'dependency specification' (in single quotes is best.)"
		print "              Here are a few examples of the dependency specification format:"
		print "              "+bold("binutils")+" matches"
		print "                  binutils-2.11.90.0.7 and binutils-2.11.92.0.12.3-r1"
		print "              "+bold(">binutils-2.11.90.0.7")+" matches"
		print "                  binutils-2.11.92.0.12.3-r1"
		print "              "+bold("sys-devel/binutils")+" matches"
		print "                  binutils-2.11.90.0.7 and binutils-2.11.92.0.12.3-r1"
		print "              "+bold("sys-devel/binutils-2.11.90.0.7")+" matches"
		print "                  binutils-2.11.90.0.7"
		print "              "+bold(">sys-devel/binutils-2.11.90.0.7")+" matches"
		print "                  binutils-2.11.92.0.12.3-r1"
		print "              "+bold(">=sys-devel/binutils-2.11.90.0.7")+" matches"
		print "                  binutils-2.11.90.0.7 and binutils-2.11.92.0.12.3-r1"
		print "              "+bold("<sys-devel/binutils-2.11.92.0.12.3-r1")+" matches"
		print "                  binutils-2.11.90.0.7"
		print "              "+bold("<=sys-devel/binutils-2.11.92.0.12.3-r1")+" matches"
		print "                  binutils-2.11.90.0.7 and binutils-2.11.92.0.12.3-r1"
		print
		print "       "+green("unmerge")+" ("+green("-C")+" short option)"
		print "              "+turquoise("WARNING: This action can remove important packages!")
		print "              Removes all matching packages without checking for outdated."
		print "              versions. This thus effectively removes a package "+bold("completely")+" from"
		print "              your system. Specify arguments using the dependency specification"
		print "              format described in the "+bold("clean")+" action above."
		print
		print "       "+green("prune")+" ("+green("-P")+" short option)"
		print "              "+turquoise("WARNING: This action can remove important packages!")
		print "              Removes all older versions of a package from your system."
		print "              This action doesn't always verify the possible binary"
		print "              incompatibility between versions and can thus remove essential"
		print "              dependencies from your system."
		print "              The argument format is the same as for the "+bold("clean")+" action."
		print
		print "       "+green("depclean")
		print "              Cleans the system by removing packages that are not associated"
		print "              with explicitly merged packages. Depclean works by creating the"
		print "              full dependancy tree from the system list and the world file,"
		print "              then comparing it to installed packages. Packages installed, but"
		print "              not associated with an explicit merge are listed as candidates"
		print "              for unmerging."+turquoise(" WARNING: This can seriously affect your system by")
		print "              "+turquoise("removing packages that may have been linked against, but due to")
		print "              "+turquoise("changes in USE flags may no longer be part of the dep tree. Use")
		print "              "+turquoise("caution when employing this feature.")
		print
		print "       "+green("search")+" ("+green("-s")+" short option)"
		print "              searches for matches of the supplied string in the current local"
		print "              portage tree. The search string is a regular expression."
		print "              A few examples: "
		print "              "+bold("emerge search '^kde'")
		print "                  list all packages starting with kde"
		print "              "+bold("emerge search 'gcc$'")
		print "                  list all packages ending with gcc"
		print "              "+bold("emerge search ''")+" or"
		print "              "+bold("emerge search '.*'")
		print "                  list all available packages "
		print
		print "       "+green("inject")+" ("+green("-i")+" short option)"
		print "              Add a stub entry for a package so that Portage thinks that it's"
		print "              installed when it really isn't.  Handy if you roll your own"
		print "              packages.  Example: "
		#NOTE: this next line *needs* the "sys-kernel/"; *please* don't remove it!
		print "              "+bold("emerge inject sys-kernel/gentoo-sources-2.4.19")
		print
		print turquoise("Options:")
		print "       "+green("--autoclean")+" ("+green("-a")+" short option)"
		print "              emerge normally cleans out the package-specific temporary"
		print "              build directory before it starts the building a package.  With"
		print "              --autoclean, it will also clean the directory *after* the"
		print "              build completes.  This option is automatically enabled for"
		print "              normal users, but maintainers can use this option to enable"
		print "              autocleaning."
		print
		print "       "+green("--buildpkg")+" ("+green("-b")+" short option)"
		print "              tell emerge to build binary packages for all ebuilds processed"
		print "              (in addition to actually merging the packages.  Useful for"
		print "              maintainers or if you administrate multiple Gentoo Linux"
		print "              systems (build once, emerge tbz2s everywhere)."
		print
		print "       "+green("--debug")+" ("+green("-d")+" short option)"
		print "              Tell emerge to run the ebuild command in --debug mode. In this"
		print "              mode, the bash build environment will run with the -x option,"
		print "              causing it to output verbose debug information print to stdout."
		print "              --debug is great for finding bash syntax errors."
		print
		print "       "+green("--emptytree")+" ("+green("-e")+" short option)"
		print "              Virtually tweaks the tree of installed packages to only contain"
		print "              glibc, this is great to use together with --pretend. This makes"
		print "              it possible for developers to get a complete overview of the"
		print "              complete dependency tree of a certain package."
		print
		print "       "+green("--fetchonly")+" ("+green("-f")+" short option)"
		print "              Instead of doing any package building, just perform fetches for"
		print "              all packages (main package as well as all dependencies.) When"
		print "              used in combination with --pretend all the SRC_URIs will be"
		print "              displayed multiple mirrors per line, one line per file."
		print
		print "       "+green("--nodeps")
		print "              Merge specified packages, but don't merge any dependencies."
		print "              Note that the build may fail if deps aren't satisfied."
		print 
		print "       "+green("--noreplace")+" ("+green("-n")+" short option)"
		print "              Skip the packages specified on the command-line that have"
		print "              already been installed.  Without this option, any packages,"
		print "              ebuilds, or deps you specify on on the command-line *will* cause"
		print "              Portage to remerge the package, even if it is already installed."
		print "              Note that Portage won't remerge dependencies by default."
		print
		print "       "+green("--oneshot")
		print "              Emerge as normal, but don't add packages to the world profile for"
		print "              later updating."
		print
		print "       "+green("--onlydeps")+" ("+green("-o")+" short option)"
		print "              Only merge (or pretend to merge) the dependencies of the"
		print "              specified packages, not the packages themselves."
		print
		print "       "+green("--pretend")+" ("+green("-p")+" short option)"
		print "              instead of actually performing the merge, simply display what"
		print "              ebuilds and tbz2s *would* have been installed if --pretend"
		print "              weren't used.  Using --pretend is strongly recommended before"
		print "              installing an unfamiliar package.  In the printout, N = new,"
		print "              U = upgrading, R = replacing, B = blocked by an already installed"
		print "              package."
		print
		print "       "+green("--searchdesc")+" ("+green("-S")+" short option)"
		print "              Matches the search string against the description field as well"
		print "              the package's name. Take caution as the descriptions are also"
		print "              matched as regular expressions."
		print "                emerge -S html"
		print "                emerge -S applet"
		print "                emerge -S 'perl.*module'"
		print
		print "       "+green("--update")+" ("+green("-u")+" short option)"
		print "              Updates packages to the most recent version available."
		print 
		print "       "+green("--usepkg")+" ("+green("-k")+" short option)"
		print "              tell emerge to use binary packages (from $PKGDIR) if they are"
		print "              available, thus possibly avoiding some time-consuming compiles."
		print "              This option is useful for CD installs; you can export"
		print "              PKGDIR=/mnt/cdrom/packages and then use this option to have"
		print "              emerge \"pull\" binary packages from the CD in order to satisfy" 
		print "              dependencies."
		print
		print "       "+green("--verbose")+" ("+green("-v")+" short option)"
		print "              Tell emerge to run in verbose mode.  Currently, this causes"
		print "              emerge to print out GNU info errors, if any."
	elif myaction in ["rsync","sync"]:
		print
		print bold("Usage: ")+turquoise("emerge")+" "+turquoise("sync")
		print
		print "       \"emerge sync\" tells emerge to update the Portage tree as specified in"
		print "       The SYNC variable found in /etc/make.conf.  By default, SYNC instructs"
		print "       emerge to perform an rsync-style update with cvs.gentoo.org.  Available"
		print "       sync methods are rsync and anoncvs.  To use anoncvs rather than rsync,"
		print "       put 'SYNC=\"cvs://:pserver:cvs.gentoo.org:/home/cvsroot\" in your"
		print "       /etc/make.conf.  If you haven't used anoncvs before, you'll be prompted"
		print "       for a password, which for cvs.gentoo.org is empty (just hit enter.)"
		print
		print "       "+turquoise("WARNING:")
		print "       If using our rsync server, emerge will clean out all files that do not"
		print "       exist on it, including ones that you may have created."
		print
	elif myaction=="system":
		print
		print bold("Usage: ")+turquoise("emerge")+" [ "+green("options")+" ] "+turquoise("system")
		print
		print "       \"emerge system\" is the Portage system update command.  When run, it"
		print "       will scan the etc/make.profile/packages file and determine what"
		print "       packages need to be installed so that your system meets the minimum"
		print "       requirements of your current system profile.  Note that this doesn't"
		print "       necessarily bring your system up-to-date at all; instead, it just"
		print "       ensures that you have no missing parts.  For example, if your system"
		print "       profile specifies that you should have sys-apps/iptables installed"
		print "       and you don't, then \"emerge system\" will install it (the most"
		print "       recent version that matches the profile spec) for you.  It's always a"
		print "       good idea to do an \"emerge --pretend system\" before an \"emerge"
		print "       system\", just so you know what emerge is planning to do."
		print
	elif myaction=="config":
		outstuff=green("Config file management support (preliminary)")+"""

Portage has a special feature called "config file protection".  The purpose of
this feature is to prevent new package installs from clobbering existing
configuration files.  By default, config file protection is turned on for /etc
and the KDE configuration dirs; more may be added in the future.

When Portage installs a file into a protected directory tree like /etc, any
existing files will not be overwritten.  If a file of the same name already
exists, Portage will change the name of the to-be- installed file from 'foo' to
'._cfg0000_foo'.  If '._cfg0000_foo' already exists, this name becomes
'._cfg0001_foo', etc.  In this way, existing files are not overwritten,
allowing the administrator to manually merge the new config files and avoid any
unexpected changes.

In addition to protecting overwritten files, Portage will not delete any files
from a protected directory when a package is unmerged.  While this may be a
little bit untidy, it does prevent potentially valuable config files from being
deleted, which is of paramount importance.

Protected directories are set using the CONFIG_PROTECT variable, normally
defined in /etc/make.globals.  Directory exceptions to the CONFIG_PROTECTed
directories can be specified using the CONFIG_PROTECT_MASK variable.  To find
files that need to be updated in /etc, type:

# find /etc -iname '._cfg????_*'

You can disable this feature by setting CONFIG_PROTECT="-*" in /etc/make.conf.
Then, Portage will mercilessly auto-update your config files.  Alternatively,
you can leave Config File Protection on but tell Portage that it can overwrite
files in certain specific /etc subdirectories.  For example, if you wanted
Portage to automatically update your rc scripts and your wget configuration,
but didn't want any other changes made without your explicit approval, you'd
add this to /etc/make.conf:

CONFIG_PROTECT_MASK="/etc/wget /etc/rc.d"

"""
		print outstuff


myaction=None
myopts=[]
myfiles=[]
edebug=0

#Freeze the portdbapi for enhanced performance:
portage.portdb.freeze()

# process short actions and options
tmpcmdline=sys.argv[1:]
tmpcmdline.extend(portage.settings["EMERGE_OPTS"].split())
cmdline=[]
for x in tmpcmdline:
	if x[0:1]=="-"and x[1:2]!="-":
		for y in x[1:]:
			if shortmapping.has_key(y):
				cmdline.append(shortmapping[y])
			else:
				print "!!! Error: -"+y+" is an invalid short action or option."
				sys.exit(1)
	else:
		cmdline.append(x)

# process the command arguments
for x in cmdline:
	if len(x)>=2 and x[0:2]=="--":
			if x in options:
				myopts.append(x)
			else:
				if x=="--clean":
					print "emerge: for rsyncs, --clean is now on by default; no need to specify this option."
				else:
					print "!!! Error:",x,"is an invalid option."
				sys.exit(1)
	elif (not myaction) and (x in actions):
		myaction=x
	elif x[-1]=="/":	
		# this little conditional helps tab completion
		myfiles.append(x[:-1])
	#elif (myaction) and (x in actions):
	#	#catch "world system" and "world foo" issues....
	#	print "emerge: please specify either \""+myaction+"\" or \""+x+"\", but not both."
	#	sys.exit(1)
	else:
		myfiles.append(x)

if (myaction in ["world", "system"]) and myfiles:
	print "emerge: please specify a package class (\"world\" or \"system\") or individual packages, but not both."
	sys.exit(1)

# Always create packages if FEATURES=buildpkg
if "buildpkg" in portage.features:
	if "--buildpkg" not in myopts:
		myopts.append("--buildpkg")

# Also allow -S to invoke search action (-sS)
if ("--searchdesc" in myopts) and (not myaction):
		myaction = "search"

# Also allow -K to apply --usepkg
if ("--usepkgonly" in myopts) and not ("--usepkg" in myopts):
		myopts.append("--usepkg")

# check if root user is the current user for the actions where emerge needs this
if ("--pretend" in myopts) or (myaction=="search"):
	if not portage.secpass:
		print "emerge: wheel group membership required for \"--pretend\" and search."
		sys.exit(1)
elif "--version" in myopts:
	print getportageversion()
	sys.exit(0)
elif "--help" in myopts:
	help()
	sys.exit(0)
elif portage.secpass!=2:
	if myaction in ["search", "help" ]:
		pass
	elif (not myaction) and (not myfiles):
		pass
	elif ("--pretend" in myopts) and (myaction in ["world","system","clean","prune","unmerge"]):
		pass
	else:
		print "myaction",myaction
		print "myopts",myopts
		print "emerge: root access required."
		sys.exit(1)

if not "--pretend" in myopts:
	emergelog("Started emerge on: "+time.strftime("%b %d, %Y %H:%M:%S", time.localtime()))
	myelogstr=""
	if myopts:
		myelogstr=string.join(myopts, " ")
	if myaction:
		myelogstr+=" "+myaction
	if myfiles:
		myelogstr+=" "+string.join(myfiles, " ")
	emergelog(" *** emerge "+myelogstr)

#configure emerge engine parameters
myparams=["self","recurse"]
add=[]
sub=[]
if "--update" in myopts:
	add.extend(["selective","empty"])
if "--emptytree" in myopts:
	add.extend(["empty"])
	sub.extend(["selective"])
if "--nodeps" in myopts:
	sub.extend(["recurse"])
if "--noreplace" in myopts:
	add.extend(["selective"])
if "--deep" in myopts:
	add.extend(["deep"])
if "--selective" in myopts:
	add.extend(["selective"])
if myaction in ["world","system"]:
	add.extend(["selective"])
elif myaction in ["depclean"]:
	sub.extend(["selective"])
	add.extend(["empty"])
for x in add:
	if (x not in myparams) and (x not in sub):
		myparams.append(x)
for x in sub:
	if x in myparams:
		myparams.remove(x)

def update_spinner():
	global spinner, spinpos
	if sys.stdout.isatty():
		sys.stdout.write("\b"+spinner[spinpos])
		spinpos=(spinpos+1)%8
		sys.stdout.flush()

# search functionality
class search:
	
	#
	# class constants
	#
	VERSION_SHORT=1
	VERSION_RELEASE=2
	
	#
	# public interface
	#
	def __init__(self):
		"""Searches the available and installed packages for the supplied search key.
		The list of available and installed packages is created at object instantiation.
		This makes successive searches faster."""
		self.installcache = portage.db["/"]["vartree"]
		
	def execute(self,searchkey):
		"""Performs the search for the supplied search key"""
		global myopts
		self.searchkey=searchkey
		self.packagematches = []
		if "--searchdesc" in myopts:
			self.searchdesc=1
			self.matches = {"pkg":[], "desc":[]}
		else:
			self.searchdesc=0
			self.matches = {"pkg":[]}
		print "Searching...   ",
		if self.searchkey=="*":
			#hack for people who aren't regular expression gurus
			self.searchkey==".*"
		if re.search("\+\+", self.searchkey):
			#hack for people who aren't regular expression gurus
			self.searchkey=re.sub("\+\+","\+\+",self.searchkey)
		for package in portage.portdb.cp_all():
			update_spinner()
			package_parts=package.split("/")
			masked=0
			if re.search(self.searchkey.lower(), package_parts[1].lower()):
				if not portage.portdb.xmatch("match-visible",package):
					masked=1
				self.matches["pkg"].append([package,masked])
			elif self.searchdesc: # DESCRIPTION searching
				full_package = portage.portdb.xmatch("bestmatch-visible",package)
				if not full_package:
					#no match found; we don't want to query description
					full_package=portage.best(portage.portdb.xmatch("match-all",package))
					if not full_package:
						continue
					else:
						masked=1
				try:
					full_desc = portage.portdb.aux_get(full_package,["DESCRIPTION"])[0]
				except KeyError:
					print "emerge: search: aux_get() failed, skipping"
					continue
				if re.search(self.searchkey.lower(), full_desc.lower()):
					self.matches["desc"].append([full_package,masked])
		self.mlen=0
		for mtype in self.matches.keys():
			self.matches[mtype].sort()
			self.mlen += len(self.matches[mtype])	

	def output(self):
		"""Outputs the results of the search."""
		print "\b\b  \n[ Results for search key : "+white(self.searchkey)+" ]"
		print "[ Applications found : "+white(str(self.mlen))+" ]"
		print " "
		for mtype in self.matches.keys():	
			for match,masked in self.matches[mtype]:
				if mtype=="pkg":
					catpack=match
					full_package = portage.portdb.xmatch("bestmatch-visible",match)
					if not full_package:
						#no match found; we don't want to query description
						masked=1
						full_package=portage.best(portage.portdb.xmatch("match-all",match))
				else:
					full_package=match
					catpack=portage.pkgsplit(match)[0]
				if full_package:
					try:
						desc, homepage = portage.portdb.aux_get(full_package,["DESCRIPTION","HOMEPAGE"])
					except KeyError:
						print "emerge: search: aux_get() failed, skipping"
						continue
					if masked:
						print green("*")+"  "+white(match)+" "+red("[ Masked ]")
					else:
						print green("*")+"  "+white(match)
					myversion = self.getVersion(full_package, search.VERSION_RELEASE)

					mysum = [0,0]
					mycat = match.split("/")[0]
					mypkg = match.split("/")[1] + "-" + myversion

					mydigest = portage.config()["PORTDIR"] + "/"  + match + "/files/digest-" + mypkg
					
					try:
						myfile = open(mydigest,"r")
						for line in myfile.readlines():
							mysum[0] += int(line.split(" ")[3])
						myfile.close()
						mystr = str(mysum[0]/1024)
						mycount=len(mystr)
						while (mycount > 3):
							mycount-=3
							mystr=mystr[:mycount]+","+mystr[mycount:]
						mysum[0]=mystr+" kB"
					except Exception, e:
						if edebug:
							print "!!! Exception:",e
						mysum[0]=" [no/bad digest]"
						
					print "     ", darkgreen("Latest version available:"),myversion
					print "     ", self.getInstallationStatus(catpack)
					print "     ", darkgreen("Size of downloaded files:"),mysum[0]
					print "     ", darkgreen("Homepage:   "),homepage
					print "     ", darkgreen("Description:"),desc
					print
		
	#
	# private interface
	#
	def getInstallationStatus(self,package):
		installed_package = self.installcache.dep_bestmatch(package)
		result = ""
		version = self.getVersion(installed_package,search.VERSION_RELEASE)
		if len(version) > 0:
			result = darkgreen("Latest version installed: ")+version
		else:
			result = darkgreen("Latest version installed:")+" [ Not Installed ]"
		return result

	def getVersion(self,full_package,detail):
		if len(full_package) > 1:
			package_parts = portage.catpkgsplit(full_package)
			if detail == search.VERSION_RELEASE and package_parts[3] != 'r0':
				result = package_parts[2]+ "-" + package_parts[3]
			else:
				result = package_parts[2]
		else:
			result = ""
		return result


#build our package digraph
def getlist(mode):
	if mode=="system":
		if portage.profiledir:
			pfile=portage.profiledir+"/packages"
		else:
			print "!!! No profile directory; system mode unavailable."
			sys.exit(1)
	elif mode=="world":
		pfile=portage.root+"var/cache/edb/world"
	try:
		myfile=open(pfile,"r")
		mylines=myfile.readlines()
		myfile.close()
	except OSError:
		print "!!! Couldn't open "+pfile+"; exiting."
		sys.exit(1)
	except IOError:
		#world file doesn't exist
		mylines=[]
	mynewlines=[]
	for x in mylines:
		myline=string.join(string.split(x))
		if not len(myline):
			continue
		elif myline[0]=="#":
			continue
		elif mode=="system":
			if myline[0]!="*":
				continue
			myline=myline[1:]
		mynewlines.append(myline.strip())
	return mynewlines

def genericdict(mylist):
	mynewdict={}
	for x in mylist:
		mynewdict[portage.dep_getkey(x)]=x
	return mynewdict

olddbapi=None
class depgraph:

	def __init__(self,myaction,myopts):
		global olddbapi
		self.myaction=myaction
		virts=portage.getvirtuals("/")
		self.digraph=portage.digraph()
		self.orderedkeys=[]
		#the following is so we have an empty vartree (used in emerge update calculations)
		self.fakedbapi=portage.fakedbapi()
		#self.fakedbapi.cpv_inject("sys-libs/glibc-2.3")	
		self.outdatedpackages=[]
		self.mydbapi={}
		if "empty" in myparams:
			#for --update, we want to rebuild an entire empty tree of dependencies, and then we won't merge was is already merged.
			self.mydbapi["/"]=self.fakedbapi
		else:
			self.mydbapi["/"]=portage.db["/"]["vartree"].dbapi
		if portage.root!="/":
			if "empty" in myparams:
				self.mydbapi[portage.root]=self.fakedbapi
			else:
				self.mydbapi[portage.root]=portage.db[portage.root]["vartree"].dbapi
			
		if "--usepkg" in myopts:
			portage.db["/"]["bintree"].populate()

	def create(self,mybigkey,myparent=None,addme=1):
		"""creates the actual digraph of packages to merge.  return 1 on success, 0 on failure
		mybigkey = specification of package to merge; myparent = parent package (one depending on me);
		addme = should I be added to the tree? (for the --onlydeps mode)"""
		#stuff to add:
		#SLOT-aware emerge
		#IUSE-aware emerge
		#"no downgrade" emerge
		jbigkey=string.join(mybigkey)
		if self.digraph.hasnode(jbigkey+" merge") or self.digraph.hasnode(jbigkey+" nomerge"):
			#this conditional is needed to prevent infinite recursion on already-processed deps
			return 1

		update_spinner()
		
		mytype,myroot,mykey=mybigkey
	
		#select the correct /var database that we'll be checking against
		vardbapi=portage.db[myroot]["vartree"].dbapi

		merging=1
		#this is where we add the node to the list of packages to merge
		if addme:
			#if the package is already on the system, we add a "nomerge" directive, otherwise we add a "merge" directive.
			if mytype=="blocks":
				#we've encountered a "blocks" node.  We will totally ignore this node and not add it to our digraph if it doesn't
				#apply to us.
				if myparent and self.mydbapi[myroot].match(mykey):
					#otherwise, encode parent information where we would normally write "(no)merge" and continue:
					parenttype,parentroot,parentkey,mergeme=string.split(myparent)
					mykexp=portage.dep_expand(mykey,self.mydbapi[myroot])
					pakexp=portage.dep_expand(parentkey,self.mydbapi[myroot])
					myrealkey=portage.dep_getkey(mykexp)
					parealkey=portage.dep_getkey(pakexp)
					if myrealkey!=parealkey:
						mybigkey.append(myparent.split()[2])
						self.digraph.addnode(string.join(mybigkey),myparent)
					#since our blocks doesn't match any installed packages, it doesn't apply to us and we can ignore it.
				return 1
			if not myparent:
				#command-line specified or part of a world list...
				if (not "self" in myparams) or (("selective" in myparams) and vardbapi.cpv_exists(mykey)):
					#the package is on the system, so don't merge it.
					merging=0
			elif ("selective" in myparams) and vardbapi.cpv_exists(mykey):
				merging=0
		else:
			#onlydeps mode; don't merge
			merging=2
		if merging==1:
			mybigkey.append("merge")
		else:
			mybigkey.append("nomerge")
			
		#whatever the case, we need to add the node to our digraph so that children can depend upon it.
		self.digraph.addnode(string.join(mybigkey),myparent)
		if (not "deep" in myparams) and (not merging):
			return 1
		elif not "recurse" in myparams:
			return 1

		edepend={}
		if mytype=="binary":
			mypkgparts=portage.catpkgsplit(mykey)
			mytbz2=xpak.tbz2(portage.db[portage.root]["bintree"].getname(mykey))
			#edepend=["",string.join(mytbz2.getelements("RDEPEND")," "),mytbz2.getfile("SLOT",mypkgparts[2])]
			# We're doing this like this for clairity.
			edepend["DEPEND"] =""
			edepend["RDEPEND"]=string.join(mytbz2.getelements("RDEPEND")," ")
			edepend["PDEPEND"]=string.join(mytbz2.getelements("PDEPEND")," ")
			edepend["REBUILD"]=string.join(mytbz2.getelements("REBUILD")," ")
			edepend["SLOT"]   =mytbz2.getfile("SLOT",mypkgparts[2])
		elif mytype=="ebuild":
			try:
				#edepend=portage.portdb.aux_get(mykey,["DEPEND","RDEPEND"])
				for x in ["DEPEND","RDEPEND","PDEPEND","REBUILD"]:
					edepend[x]=string.join(portage.portdb.aux_get(mykey,[x]), " ")
			except (KeyError,IOError):
				print "emerge: create(): aux_get() error on",mykey+"; aborting..."
				sys.exit(1)
		mydep={}	
		mp=string.join(mybigkey)

		if myroot=="/":
			mydep["/"]=edepend["DEPEND"]+" "+edepend["RDEPEND"]
			if not self.select_dep("/",mydep["/"],myparent=mp):
				return 0
		else:
			mydep["/"]=edepend["DEPEND"]
			mydep[myroot]=edepend["RDEPEND"]
			if not self.select_dep("/",mydep["/"],myparent=mp):
				return 0
			elif not self.select_dep(myroot,mydep[myroot],myparent=mp):
				return 0

		if edepend.has_key("PDEPEND") and edepend["PDEPEND"]:
			# Post Depend -- Add to the list without a parent, as it depends
			# on a package being present AND must be built after that package.
			if not self.select_dep(myroot,edepend["PDEPEND"]):
				return 0
			
		return 1
			
	def select_files(self,myfiles):
		"given a list of .tbz2s, .ebuilds and deps, create the appropriate depgraph and return a favorite list"
		myfavorites=[]
		for x in myfiles:
			if x[-5:]==".tbz2":
				mytbz2=xpak.tbz2(x)
				mykey=mytbz2.getelements("CATEGORY")[0]+"/"+os.path.basename(x)[:-5]
				if not self.create(["binary",portage.root,mykey],None,"--onlydeps" not in myopts):
					return (0,myfavorites)
				elif not "--oneshot" in myopts:
					myfavorites.append(mykey)
			elif x[-7:]==".ebuild":
				mykey=os.path.basename(os.path.abspath(x+"/../.."))+"/"+os.path.basename(x)[:-7]
				if not self.create(["ebuild",portage.root,mykey],None,"--onlydeps" not in myopts):
					return (0,myfavorites)
				elif not "--oneshot" in myopts:
					myfavorites.append(mykey)
			else:
				mykey=portage.dep_expand(x,portage.portdb)
				#select needs to return 0 on dep_check failure
				try:
					self.mysd=self.select_dep(portage.root,mykey,arg=x)
				except Exception, e:
					print "\n!!! Problem in",mykey,"dependancies."
					print "!!!",e
					sys.exit(1)

				if not self.mysd:
					return (0,myfavorites)
				elif not "--oneshot" in myopts:
					myfavorites.append(mykey)

		self.missingbins=0
		if "--usepkgonly" in myopts:
			for x in self.digraph.dict.keys():
				xs=string.split(x," ")
				if (xs[0] != "binary") and (xs[3]=="merge"):
					if self.missingbins == 0:
						print
					self.missingbins+=1
					print "Missing binary for:",xs[2]

		# We're true here unless we are missing binaries.
		return (not self.missingbins,myfavorites)

	def select_dep(self,myroot,depstring,myparent=None,arg=None):
		"given a dependency string, create the appropriate depgraph and return 1 on success and 0 on failure"
		if not arg:
			#processing dependencies
			mycheck=portage.dep_check(depstring,self.mydbapi[myroot])
			if not mycheck[0]:
				return 0
			mymerge=mycheck[1]
		else:
			#we're processing a command-line argument; unconditionally merge it even if it's already merged
			mymerge=[depstring]
		for x in mymerge:
			if x[0]=="!":
				#add our blocker; it will be ignored later if necessary (if we are remerging the same pkg, for example)
				myk=["blocks",myroot,x[1:]]
			else:
				#We are not processing a blocker but a normal dependency
				myeb=portage.portdb.xmatch("bestmatch-visible",x)
				if not myeb:
					if not arg:
						xinfo='"'+x+'"'
					else:
						xinfo='"'+arg+'"'
					if myparent:
						xfrom = '(dependency required by '+green('"'+myparent.split()[2]+'"')+red(' ['+myparent.split()[0]+"])")
					alleb=portage.portdb.xmatch("match-all",x)
					if alleb:
						print "\n\n!!! "+red("all ebuilds that could satisfy ")+green(xinfo)+red(" have been masked.")
					if myparent:
						print     "!!!    "+red(xfrom)
					else:
						print "\n\nemerge: there are no masked or unmasked ebuilds to satisfy "+xinfo+"."
					return 0
				
				if "--usepkg" in myopts:
					#If we want to use packages, see if we have a pre-built one...
					mypk=portage.db["/"]["bintree"].dbapi.match(x)
					if myeb in mypk:
						#Use it only if it's exactly the version we want.
						myk=["binary",myroot,myeb]
					else:
						myk=["ebuild",myroot,myeb]
				else:
					myk=["ebuild",myroot,myeb]
			if myparent:
				#we are a dependency, so we want to be unconditionally added
				if not self.create(myk,myparent):
					return 0
			else:
				#if mysource is not set, then we are a command-line dependency and should not be added
				#if --onlydeps is specified.
				if not self.create(myk,myparent,"--onlydeps" not in myopts):
					return 0
		return 1
		

	def altlist(self):
		mygraph=self.digraph.copy()
		dolist=["/"]
		retlist=[]
		for x in portage.db.keys():
			portage.db[x]["merge"]=[]
			if x not in dolist:
				dolist.append(x)
		while (not mygraph.empty()):
			mycurkey=mygraph.firstzero()
			if not mycurkey:
				print "!!! Error: circular dependencies:"
				print
				for x in mygraph.dict.keys():
					for y in mygraph.dict[x][1]:
						print y,"depends on",x
				print
				sys.exit(1)
			splitski=string.split(mycurkey)
			#I'm not sure of the significance of the following lines (vestigal?) so I'm commenting 'em out.
			#These lines remove already-merged things from our alt-list
			#if "--update" in myopts:
			#	if not portage.db["/"]["vartree"].exists_specific(splitski[2]):
			#		portage.db["/"]["merge"].append(splitski)
			#else:
			portage.db[splitski[1]]["merge"].append(splitski)	
			mygraph.delnode(mycurkey)
		for x in dolist:
			for y in portage.db[x]["merge"]:
				retlist.append(y)
		return retlist

	def xcreate(self,mode="system"):
		global syslist
		if mode=="system":
			mylist=syslist
		else:
			#world mode
			worldlist=getlist("world")
			sysdict=genericdict(syslist)
			worlddict=genericdict(worldlist)
			#we're effectively upgrading sysdict to contain all new deps from worlddict
			for x in worlddict.keys():
				#only add the world node if the package is:
				#actually installed -- this prevents the remerging of already unmerged packages when we do a world --update;
				#actually available -- this prevents emerge from bombing out due to no match being found (we want a silent ignore)
				if "empty" in myparams:
					if portage.db["/"]["vartree"].dbapi.match(x):
						sysdict[x]=worlddict[x]
				elif portage.db[portage.root]["vartree"].dbapi.match(x):
					#package is installed
					sysdict[x]=worlddict[x]
				else:
					print "\n*** Package in world file is not installed: "+x
			mylist=[]
			for x in sysdict.keys():
				mylist.append(sysdict[x])

		for mydep in mylist:	
			myeb=portage.portdb.xmatch("bestmatch-visible",mydep)
			if not myeb:
				#this is an unavailable world entry; just continue
				continue
			#THIS NEXT BUNCH OF CODE NEEDS TO BE REPLACED TO SUPPORT WORLD ANTI-DEPS
			#if mydep2[0]=="!":, etc.
			if "--usepkg" in myopts:
				mypk=portage.db[portage.root]["bintree"].dep_bestmatch(mydep)
				if myeb==mypk:
					myk=["binary",portage.root,mypk]
				else:
					myk=["ebuild",portage.root,myeb]
			else:
				myk=["ebuild",portage.root,myeb]
			if not self.create(myk):
				return 0
		return 1

	def match(self,mydep,myroot=portage.root,mykey=None):
		# support mutual exclusive deps
		mydep2=mydep
		if mydep2[0]=="!":
			mydep2=mydep[1:]

		if mydep[0]=="!":
			#add our blocker; it will be ignored later if necessary (if we are remerging the same pkg, for example)
			myk="blocks "+myroot+" "+mydep2
		else:
			myeb=portage.db[portage.root]["porttree"].dep_bestmatch(mydep2)
			if not myeb:
				if not mykey:
					print "\n!!! Error: couldn't find match for",mydep
				else:
					print "\n!!! Error: couldn't find match for",mydep,"in",mykey
				print
				sys.exit(1)

			if "--usepkg" in myopts:
				mypk=portage.db[portage.root]["bintree"].dep_bestmatch(mydep)
				if myeb==mypk:
					myk="binary "+portage.root+" "+mypk
				else:
					myk="ebuild "+myroot+" "+myeb
			else:
				myk="ebuild "+myroot+" "+myeb

		return myk	
	
	def display(self,mylist):
		for x in mylist:
			if x[0]=="blocks":
				addl=""+red("B")+"    "
				resolved=portage.db[x[1]]["vartree"].resolve_key(x[2])
				print "["+x[0]+" "+addl+"]",red(resolved),
				if resolved!=x[2]:
					if x[3]:
						print red("(\""+x[2]+"\" from pkg "+x[3]+")")
					else:
						print red("(\""+x[2]+"\")")
				else:
					if x[3]:
						print red("(from pkg "+x[3]+")")
					else:
						print
			else:
				if x[3]=="nomerge":
					continue
				#we need to use "--emptrytree" testing here rather than "empty" param testing because "empty"
				#param is used for -u, where you still *do* want to see when something is being upgraded.
				myoldbest=""
				if (not "--emptytree" in myopts) and portage.db[x[1]]["vartree"].exists_specific(x[2]):
					addl="  "+yellow("R")+"  "
				elif (not "--emptytree" in myopts) and portage.db[x[1]]["vartree"].exists_specific_cat(x[2]):
					myoldbest=portage.best(portage.db[x[1]]["vartree"].dbapi.match(portage.pkgsplit(x[2])[0]))
					if portage.pkgcmp(portage.pkgsplit(x[2]), portage.pkgsplit(myoldbest)) < 0:
						addl="   "+turquoise("U")+blue("D")
					else:
						addl="   "+turquoise("U")+" "
				else:
					addl=" "+green("N")+"   "
				if myoldbest:
					myoldbest=blue("["+portage.pkgsplit(myoldbest)[1]+"-"+portage.pkgsplit(myoldbest)[2]+"]")
				if x[1]!="/":
					print "["+x[0]+" "+addl+"]",x[2],myoldbest,darkgreen("to "+x[1])
				else:
					print "["+x[0]+" "+addl+"]",x[2],myoldbest

			mysplit=portage.pkgsplit(x[2])
			# XXX mysplit _can_ be None.... Why?
			if mysplit and "--emptytree" not in myopts:
				if mysplit[0]=="sys-apps/portage":
					if mysplit[1]+"-"+mysplit[2]!=portage.VERSION:
						if mylist.index(x)<len(mylist)-1:
							print red("*** Portage will stop merging at this point and reload itself,")
							print red("    recalculate dependancies, and complete the merge.")
							if "--update" not in myopts:
								print darkgreen("    You may avoid the remerging of packages by updating portage on its own.")
							print
			else:
				if mysplit[0]=="sys-apps/portage":
					if mysplit[1]+"-"+mysplit[2]!=portage.VERSION:
						print red("!!!")+" Please update portage to the above version before proceeding."
						print "    Failure to do so may result in failed or improper merges."
						print "    A simple '"+green("emerge -u portage")+"' is sufficient."
						print
			del mysplit

	def outdated(self):
		return self.outdatedpackages
				
	def merge(self,mylist):
		returnme=0
		#check for blocking dependencies
		for x in mylist:
			if x[0]=="blocks":
				print "\n!!! Error: the "+x[2]+" package conflicts with this package and both can't be installed on the same system together."
				sys.exit(1)

		mymergelist=[]
		for x in range(len(mylist)):
			if mylist[x][3]!="nomerge":
				mymergelist.append(mylist[x])

		mergecount=0
		for x in mymergelist:
			mergecount+=1
			myroot=x[1]
			#the last argument in the portage.doebuild() tells doebuild to *not* do dep checking
			#(emerge is already handling that)
			y=portage.portdb.findname(x[2])
			if not "--pretend" in myopts:
				print ">>> emerge ("+str(mergecount)+" of "+str(len(mymergelist))+")",x[2],"to",x[1]
				emergelog(" >>> emerge ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[2]+" to "+x[1])
			if x[0]=="ebuild":
				if "--fetchonly" in myopts:
					retval=portage.doebuild(y,"fetch",myroot,edebug,("--pretend" in myopts))
					if retval:
						print
						print "!!! Fetch for",y,"failed, continuing..."
						print	
						returnme=1
				elif "--buildpkg" in myopts:
					#create pkg, then merge pkg
					retval=portage.doebuild(y,"clean",myroot,edebug)
					if retval:
						sys.exit(1)
					retval=portage.doebuild(y,"package",myroot,edebug)
					if retval:
						sys.exit(1)
					#dynamically update our database	
					portage.db[portage.root]["bintree"].inject(x[2])
					mytbz2=portage.db[portage.root]["bintree"].getname(x[2])
					retval=portage.pkgmerge(mytbz2,myroot)
					if retval==None:
						sys.exit(1)
				else:
					retval=portage.doebuild(y,"clean",myroot,edebug)
					if retval:
						sys.exit(1)
					retval=portage.doebuild(y,"merge",myroot,edebug)
					if retval:
						sys.exit(1)
					#dynamically update our database	
			elif x[0]=="binary":
				#merge the tbz2
				mytbz2=portage.db[portage.root]["bintree"].getname(x[2])
				retval=portage.pkgmerge(mytbz2,x[1])
				if retval==None:
					sys.exit(1)
				#need to check for errors
			portage.db[x[1]]["vartree"].inject(x[2])
			myfavkey=portage.cpv_getkey(x[2])
			if (not "--fetchonly" in myopts) and (myfavkey in favorites):
				myfavs=portage.grabfile(myroot+"var/cache/edb/world")
				myfavdict=genericdict(myfavs)
				mysysdict=genericdict(syslist)
				#don't record if already in system profile or already recorded
				if (not mysysdict.has_key(myfavkey)) and (not myfavdict.has_key(myfavkey)):
					#we don't have a favorites entry for this package yet; add one
					myfavdict[myfavkey]=myfavkey
					print ">>> Recording",myfavkey,"in \"world\" favorites file..."
					portage.writedict(myfavdict,myroot+"var/cache/edb/world",writekey=0)

			if "--autoclean" in myopts:
				retval=portage.doebuild(y,"clean",myroot,edebug)
				if retval:
					sys.exit(1)
			
			if ("--pretend" not in myopts) and ("--fetchonly" not in myopts):
				# Clean the old package that we have merged over top of it.
				if portage.settings["AUTOCLEAN"] and (portage.settings["AUTOCLEAN"]=="yes"):
					xsplit=portage.pkgsplit(x[2])
					emergelog(" >>> AUTOCLEAN: "+xsplit[0])
					if not unmerge("clean", [xsplit[0]]):
						emergelog(" --- AUTOCLEAN: Nothing unmerged.")
				emergelog(" ::: completed emerge ("+str(mergecount)+" of "+str(len(mymergelist))+") "+x[2]+" to "+x[1])

				mysplit=portage.pkgsplit(x[2])
				if mysplit[0]=="sys-apps/portage":
					if mysplit[1]+"-"+mysplit[2]!=portage.VERSION:
						if len(mymergelist) > mergecount:
							myargv=sys.argv
							myr=0
							for myra in range(len(myargv)):
								print "Considering:",myargv[myr]
								if myargv[myr][0:len("portage")]=="portage":
									print "deleted:",myargv[myr]
									del myargv[myr]
									myr-=1
								if myargv[myr][0:len("sys-apps/portage")]=="sys-apps/portage":
									print "deleted:",myargv[myr]
									del myargv[myr]
									myr-=1
								myr+=1
							emergelog(" *** RESTARTING emerge via exec() after change of portage version.")
							os.execv("/usr/lib/portage/bin/emerge", myargv)

		if ("--pretend" not in myopts) and (mergecount>0):
			portage.env_update()


		#by doing an exit this way, --fetchonly can continue to try to
		#fetch everything even if a particular download fails.
		if "--fetchonly" in myopts:
			if returnme:
				print "\n\n!!! Some fetch errors were encountered.  Please see above for details.\n\n"
				sys.exit(returnme)
			else:
				sys.exit(0)

def unmerge(unmerge_action, unmerge_files):
	candidate_catpkgs=[]
	global_unmerge=0
	
	if not unmerge_files or "world" in unmerge_files or "system" in unmerge_files:
		if "unmerge"==unmerge_action:
			print
			print bold("emerge unmerge")+" can only be used with specific package names, not with "+bold("world")+" or"
			print bold("system")+" targets."
			print
			return 0
		else:
			global_unmerge=1
	
	localtree=portage.db[portage.root]["vartree"]
	# process all arguments and add all valid db entries to candidate_catpkgs
	if global_unmerge:
		if not unmerge_files or "world" in unmerge_files:
			candidate_catpkgs.extend(localtree.getallnodes())	
		elif "system" in unmerge_files:
			candidate_catpkgs.extend(getlist("system"))
	else:
		#we've got command-line arguments
		if not unmerge_files:
			print "\nNo packages to unmerge have been provided.\n"
			return 0
		for x in unmerge_files:
			arg_parts=x.split('/')
			if arg_parts[-1][-7:]!=".ebuild":
				#possible cat/pkg or dep; treat as such
				candidate_catpkgs.append(x)
			elif unmerge_action in ["prune","clean"]:
				print "\n!!! Prune and clean do not accept individual ebuilds as arguments;\n    skipping.\n"
				continue
			else:
				# it appears that the user is specifying an installed ebuild and we're in "unmerge" mode, so it's
				# ok.
				if not os.path.exists(x):
					print "\n!!! The path '"+x+"' doesn't exist.\n"
					return 0
				absx=os.path.abspath(x)
				spabsx=absx.split("/")
				if absx[:12]!="/var/db/pkg/" or len(spabsx)!=7:
					print spabsx
					print absx
					print "\n!!!",x,"is not inside /var/db/pkg; aborting.\n"
					return 0
				candidate_catpkgs.append("="+spabsx[4]+"/"+spabsx[5])

	if "--pretend" in myopts:
		print"\n>>> These are the packages that I would unmerge:"
	
	pkgmap={}
	numselected=0
	for x in candidate_catpkgs:
		#cycle through all our candidate deps and determine what will and will not get unmerged
		mymatch=localtree.dep_match(x)
		if not mymatch and x[0] not in "<>=~":
			#add a "=" if missing
			mydep="="+x
			mymatch=localtree.dep_match(mydep)
		else:
			mydep=x
		mykey=portage.key_expand(portage.dep_getkey(mydep),portage.db["/"]["vartree"].dbapi)
		if not mymatch:
			print "\n!!! Couldn't find match for",white(x)
			continue
		if not pkgmap.has_key(mykey):
			pkgmap[mykey]={"protected":[], "selected":[], "omitted":[] }
		if unmerge_action=="unmerge":
				for y in mymatch:
					if not y in pkgmap[mykey]["selected"]:
						pkgmap[mykey]["selected"].append(y)
						numselected=numselected+len(mymatch)
		else:
			#unmerge_action in ["prune", clean"]
			slotmap={}
			for mypkg in mymatch:
				if unmerge_action=="clean":
					myslot=localtree.getslot(mypkg)
				else:
					#since we're pruning, we don't care about slots and put all the pkgs in together
					myslot=0
				if not slotmap.has_key(myslot):
					slotmap[myslot]={}
				slotmap[myslot][localtree.dbapi.cpv_counter(mypkg)]=mypkg
			for myslot in slotmap.keys():
				counterkeys=slotmap[myslot].keys()
				counterkeys.sort()
				if not counterkeys:
					continue
				counterkeys.sort()
				pkgmap[mykey]["protected"].append(slotmap[myslot][counterkeys[-1]])
				del counterkeys[-1]
				#be pretty and get them in order of merge:
				for ckey in counterkeys:
					pkgmap[mykey]["selected"].append(slotmap[myslot][ckey])
					numselected=numselected+1
				#ok, now the last-merged package is protected, and the rest are selected
		for y in localtree.dep_nomatch(mydep):
			if not y in pkgmap[mykey]["omitted"]:
				pkgmap[mykey]["omitted"].append(y)
		
	if global_unmerge and not numselected:
		print "\n>>> No outdated packages were found on your system.\n"
		return 0
	
	for x in pkgmap.keys():
		if global_unmerge and not pkgmap[x]["selected"]:
			#avoid cluttering the preview printout with stuff that isn't getting unmerged
			continue
		print "\n "+white(x)
		for mytype in ["selected","protected","omitted"]:
			print string.rjust(mytype,12)+":",
			if pkgmap[x][mytype]:
				for mypkg in pkgmap[x][mytype]:
					mysplit=portage.catpkgsplit(mypkg)
					if mysplit[3]=="r0":
						myversion=mysplit[2]
					else:
						myversion=mysplit[2]+"-"+mysplit[3]
					if mytype=="selected":
						print red(myversion),
					else:
						print green(myversion),
			else:
					print "none",
			print
	
	if not numselected:
		print "\n>>>",unmerge_action+": No packages selected for removal.\n"
		return 0

	print "\n>>> Packages in",red("red"),"are slated for removal."
	print ">>> Packages in",green("green"),"will not be removed.\n"
	
	if "--pretend" in myopts:
		#we're done... return
		return 0
	#the real unmerging begins, after a short delay....
	
	if portage.settings["CLEAN_DELAY"]:
		secs=string.atoi(portage.settings["CLEAN_DELAY"])
	else:
		secs=5
	countdown(secs, ">>> Unmerging")

	for x in pkgmap.keys():
		for y in pkgmap[x]["selected"]:
			print ">>> Unmerging "+y+"..."
			mysplit=string.split(y,"/")
			#unmerge...
			retval=portage.unmerge(mysplit[0],mysplit[1],portage.root)
			if retval:
				emergelog(" !!! unmerge FAILURE: "+y)
			else:
				emergelog(" >>> unmerge success: "+y)
	#run ldconfig, etc...
	portage.env_update()
	if not numselected:
		return 0
	else:
		return 1


def post_emerge(retval=0):
	auxpat=re.compile('^([^-]*)(-\d+)?\.info(-\d+)?(\.gz)?')	
	global myopts
	print
	if "--pretend" in myopts:
		sys.exit(retval)
	emergelog(" *** exiting successfully.")
	root=portage.root

	if os.path.exists("/usr/bin/install-info"):
		for z in string.split(portage.settings["INFOPATH"]+":"+portage.settings["INFODIR"], ":"):
			inforoot=root+z
			if os.path.isdir(inforoot):
				try:
					infomtime=os.stat(inforoot)[ST_MTIME]
				except:
					infomtime=0
				regen=1

			if not portage.mtimedb.has_key("info"):
				portage.mtimedb["info"]={}
			if portage.mtimedb["info"].has_key(inforoot):
				if portage.mtimedb["info"][inforoot]==infomtime:
					regen=0
				else:
					portage.mtimedb["info"][inforoot]=0


		if not regen:
			print " "+green("*")+" GNU info directory index is up-to-date."
		else:
			print " "+green("*")+" Regenerating GNU info directory index..."

			icount=0
			badcount=0
			for z in string.split(portage.settings["INFOPATH"]+":"+portage.settings["INFODIR"], ":"):
				inforoot=root+z
				if portage.mtimedb["info"].has_key(inforoot):
					if portage.mtimedb["info"][inforoot]!=0:
						continue
				try:
					os.rename(inforoot+"/dir",inforoot+"/dir.old")
				except:
					pass
				
				if not os.path.isdir(inforoot):
					continue
				for x in os.listdir(inforoot):
					aux=auxpat.search(x)
					if not aux:
						continue
					auxgroups=aux.groups()	
					if not (auxgroups[1] or auxgroups[2]):
						myso=commands.getstatusoutput("/usr/bin/install-info --dir-file="+inforoot+"/dir "+inforoot+"/"+x)[1]
						if myso!="":
							badcount=badcount+1
							if "--verbose" in myopts:
								print myso
						icount=icount+1
				#update mtime so we can potentially avoid regenerating.
				portage.mtimedb["info"][inforoot]=os.stat(inforoot)[ST_MTIME]

			if badcount:
				if "--verbose" not in myopts:
					print " "+yellow("*")+" Processed",icount,"info files:",badcount,"errors; type "+green("emerge --verbose")+" to view errors."
				else:
					print " "+yellow("*")+" Processed",icount,"info files;",badcount,"errors."
			else:
				print " "+green("*")+" Processed",icount,"info files."

	if portage.settings["CONFIG_PROTECT"]:
		#number of directories with some protect files in them
		procount=0
		for x in string.split(portage.settings["CONFIG_PROTECT"]):
			if os.path.isdir(x):
				a=commands.getstatusoutput("cd "+x+"; find -iname '._cfg????_*'")
				if a[0]!=0:
					print " "+red("*")+" error scanning",x
				else:
					files=string.split(a[1])
					if files:
						procount=procount+1
						print " "+yellow("* IMPORTANT:")+"",len(files),"config files in",x,"need updating."
		if procount:
			print " "+yellow("*")+" Type "+green("emerge --help config")+" to learn how to update config files."
		print
	sys.exit(retval)

# general options that should be taken into account before any action
if "noclean" not in portage.features:
	if not "--autoclean" in myopts:
		myopts.append("--autoclean")
if "--debug" in myopts:
	edebug=1

if myaction in ["sync","rsync"] and (not "--help" in myopts):
	if "--pretend" in myopts:
		print "emerge: the \"sync\" and \"rsync\" actions do not support \"--pretend.\""
		sys.exit(1)

	emergelog(" === rsync")
	myportdir=portage.settings["PORTDIR"]
	if myportdir[-1]=="/":
		myportdir=myportdir[:-1]
	if not os.path.exists(myportdir):
		print ">>>",myportdir,"not found, creating it."
		os.makedirs(myportdir,0755)	
	syncuri=portage.settings["SYNC"]
	os.umask(022)
	if syncuri[:8]=="rsync://":
		if not os.path.exists("/usr/bin/rsync"):
			print "!!! /usr/bin/rsync does not exist, so rsync support is disabled."
			print "!!! Type \"emerge net-misc/rsync\" to enable rsync support."
			sys.exit(1)
		mycommand="/usr/bin/rsync -rlptDvz --progress --stats --delete --delete-after --exclude='distfiles/*' --exclude='packages/*' "
		mycommand=mycommand+syncuri+"/* "+myportdir
		print ">>> starting rsync with "+syncuri+"..."
		#protect users that did not set a default umask
		exitcode=portage.spawn(mycommand,free=1)
		#if the exit code of rsync is 12 retry to rsync till
		#we have reached RSYNC_RETRIES or the default of 3 retries
		try:
			maxretries=int(portage.settings["RSYNC_RETRIES"])
		except:
			maxretries=3 #default number of retries
		retries=1
		while exitcode==12 and retries<=maxretries:
			print ">>> Starting retry %d of %d"% (retries,maxretries)
			retries=retries+1
			exitcode=portage.spawn(mycommand,free=1)
	elif syncuri[:6]=="cvs://":
		if not os.path.exists("/usr/bin/cvs"):
			print "!!! /usr/bin/cvs does not exist, so rsync support is disabled."
			print "!!! Type \"emerge dev-util/cvs\" to enable CVS support."
			sys.exit(1)
		cvsroot=syncuri[6:]
		cvsdir=os.path.dirname(myportdir)
		if not os.path.exists(myportdir+"/CVS"):
			#initial checkout
			print ">>> starting initial cvs checkout with "+syncuri+"..."
			if not portage.spawn("cd "+cvsdir+"; cvs -d "+cvsroot+" login",free=1):
				print "!!! cvs login error; exiting."
				sys.exit(1)
			if os.path.exists(cvsdir+"/gentoo-x86"):
				print "!!! existing",cvsdir+"/gentoo-x86 directory; exiting."
				sys.exit(1)
			if not portage.spawn("cd "+cvsdir+"; cvs -z3 -d "+cvsroot+" co gentoo-x86",free=1):
				print "!!! cvs checkout error; exiting."
				sys.exit(1)
			if cvsdir!=myportdir:
				portage.movefile(cvsdir,portage.settings["PORTDIR"])
			sys.exit(0)
		else:
			#cvs update
			print ">>> starting cvs update with "+syncuri+"..."
			sys.exit(portage.spawn("cd "+myportdir+"; cvs -z3 -q update -dP",free=1)) 
	else:
		print "!!! rsync setting: ",syncuri,"not recognized; exiting."
		sys.exit(1)
	if os.path.exists(myportdir+"/metadata/cache"):
		print "\n>>> Updating Portage cache...  ",
		mynodes=portage.portdb.cp_all()
		for x in mynodes:
			myxsplit=x.split("/")
			mycatdir=portage.settings["PORTAGE_CACHEDIR"]+"/"+myxsplit[0]
			if not os.path.exists(mycatdir):
				os.makedirs(mycatdir,02775)
				os.chown(mycatdir,0,portage.wheelgid)
			mymatches=portage.portdb.xmatch("match-all",x)
			for y in mymatches:
				update_spinner()
				curdbkey=portage.settings["PORTAGE_CACHEDIR"]+"/"+y
				newdbkey=myportdir+"/metadata/cache/"+y
				mysplit=y.split("/")
				myebuild=myportdir+"/"+myxsplit[0]+"/"+myxsplit[1]+"/"+mysplit[1]+".ebuild"
				notfound=0
				try:
					ebuildtime=os.stat(myebuild)[ST_MTIME]
				except OSError:
					notfound=1
				if notfound:
					continue
				curkeytime=0
				notfound=0
				try:
					newkeytime=os.stat(newdbkey)[ST_MTIME]
				except OSError:
					notfound=1
				if notfound:
					continue
				try:
					curkeytime=os.stat(curdbkey)[ST_MTIME]
				except OSError:
					pass
				if (newkeytime>=ebuildtime>curkeytime):
					shutil.copy(newdbkey,curdbkey)
					os.chown(curdbkey,0,portage.wheelgid)
		sys.stdout.write("\b\b  \n\n")
		sys.stdout.flush()
elif myaction=="regen":
	emergelog(" === regen")
	#regenerate cache entries
	mynodes=portage.portdb.cp_all()
	for x in mynodes:
		mymatches=portage.portdb.xmatch("list-visible",x)
		print "processing",x
		for y in mymatches:
			try:
				foo=portage.portdb.aux_get(y,["DEPEND"])
			except:
				print "error processing",y+", continuing..."
	print "done!"
# HELP action
elif "config"==myaction:
	emergelog(" === config")
	print
	print "Currently, \'config\' is a --help option only."
	print
# INFO action
elif "info"==myaction:
	unameout=commands.getstatusoutput("/bin/uname -mrp")[1]
	print getportageversion()
	print "================================================================="
	print "System uname: "+unameout
	for x in ['USE', 'ARCH', 'COMPILER', 'CHOST', 'CFLAGS', 'CXXFLAGS',
	          'ACCEPT_KEYWORDS', 'CONFIG_PROTECT', 'CONFIG_PROTECT_MASK',
						'MAKEOPTS', 'JDK_HOME', 'JAVA_HOME', 'AUTOCLEAN', 'SYNC',
						'GENTOO_MIRRORS']:
		print x+'="'+portage.settings[x]+'"'
	#print portage.settings.keys()
	print
# SEARCH action
elif "search"==myaction:
	if not myfiles:
		print "emerge: no search terms provided."
	else:
		
		searchinstance = search()
		for mysearch in myfiles:
			try:
				searchinstance.execute(mysearch)
			except re.error, comment:
				print "\n!!! Regular expression error in \"%s\": %s" % ( mysearch, comment )
				sys.exit(1)
			searchinstance.output()
elif "inject"==myaction:
	if not myfiles:
		print "emerge: please specify at least one cat/pkg-ver to inject."
		sys.exit(1)
	if "--pretend" in myopts:
		print "emerge: the \"inject\" action does not support \"--pretend.\""
		sys.exit(1)
	for x in myfiles:
		mycps=portage.catpkgsplit(x)
		if (not mycps) or (mycps[0]=="null"):
			print "!!!",x,"is not a specific cat/pkg-version, skipping..."
			continue
		if portage.db["/"]["vartree"].exists_specific(x):
			print "!!! Not injecting",x+"; Package already exists."
		else:
			portage.db["/"]["vartree"].dbapi.cpv_inject(x)
			print ">>> Injected",x+"."
			emergelog(" === inject: "+x)
elif "unmerge"==myaction or "prune"==myaction or "clean"==myaction:
	if 1==unmerge(myaction, myfiles):
		post_emerge()
	
elif "depclean"==myaction:
	# Kill packages that aren't explicitly merged or are required as a
	# dependancy of another package. World file is explicit.

	print
	print red("*** WARNING ***")+" : DEPCLEAN CAN  SERIOUSLY  IMPAIR YOUR SYSTEM. USE CAUTION."
	print red("*** WARNING ***")+" : (Cancel: CONTROL-C) -- ALWAYS VERIFY ALL PACKAGES IN THE"
	print red("*** WARNING ***")+" : CANDIDATE LIST FOR  SANITY  BEFORE  ALLOWING DEPCLEAN TO"
	print red("*** WARNING ***")+" : UNMERGE ANY PACKAGES."
	print red("*** WARNING ***")+" :"
	print red("*** WARNING ***")+" : USE FLAGS MAY HAVE AN EXTREME EFFECT ON THE OUTPUT."
	print red("*** WARNING ***")+" : SOME LIBRARIES MAY BE USED BY PACKAGES BUT ARE NOT"
	print red("*** WARNING ***")+" : CONSIDERED TO BE A DEPEND DUE TO USE FLAG SETTINGS."
	print red("*** WARNING ***")+" :"
	print red("*** WARNING ***")+" : Packages  in the list  that are  desired  may be added"
	print red("*** WARNING ***")+" : directly to the world file to cause them to be ignored"
	print red("*** WARNING ***")+" : by declean and maintained in the future. BREAKAGES DUE"
	print red("*** WARNING ***")+" : TO UNMERGING AN  IN-USE  LIBRARIES  MAY BE REPAIRED BY"
	print red("*** WARNING ***")+" : MERGING  *** THE PACKAGE THAT COMPLAINS ***  ABOUT THE"
	print red("*** WARNING ***")+" : MISSING LIBRARY."
	print
	if not "--pretend" in myopts:
		countdown(10, ">>> Depclean")
		emergelog(" >>> depclean")

	mydepgraph=depgraph(myaction,myopts)
	syslist=getlist("system")
	worldlist=getlist("world")

	print "Calculating",myaction,"dependencies  ",
	if not mydepgraph.xcreate("world"):
		print "\n!!! Failed to create deptree."
		sys.exit(1)
	print "\b\b ... done!"

	alldeps=mydepgraph.digraph.allnodes()
	myvarlist=portage.vardbapi(portage.root).cp_all()

	if not syslist:
		print "!!! You have no system list. Cannot determine system from world."
	if not worldlist:
		print "!!! You have no world file. Cannot determine explicit merges."
	if not myvarlist:
		print "!!! You have no /var/db tree. This is a problem."
	if not alldeps:
		print "!!! You have no dependancies. Impossible. Bug."

	if not (syslist and worldlist and myvarlist and alldeps):
		print
		sys.exit(1)

	reallist=[]
	for x in range(len(alldeps)-1):
		myparts=portage.catpkgsplit(string.split(alldeps[x])[2])
		catpack=myparts[0]+"/"+myparts[1]
		if catpack not in reallist:
			reallist.append(myparts[0]+"/"+myparts[1])

	cleanlist=[]
	for x in myvarlist:
		if x not in reallist:
			if x not in cleanlist:
				cleanlist.append(x)

	for x in syslist+worldlist:
		myparts = portage.catpkgsplit(x)
		if myparts:
			if myparts[0][0] in ('<','>','='):
				myparts[0] = myparts[0][1:]
			if myparts[0][0] in ('<','>','='):
				myparts[0] = myparts[0][1:]
			catpack=myparts[0]+"/"+myparts[1]
		else:
			catpack=x
		if catpack in cleanlist:
			cleanlist.remove(catpack)

	#print "\n\n\nCleaning: "
	#for x in cleanlist:
	#	print x
	#print

	if len(cleanlist):
		unmerge("unmerge", cleanlist)

	print
	print "Packages installed:   "+str(len(myvarlist))
	print "Packages in world:    "+str(len(worldlist))
	print "Packages in system:   "+str(len(syslist))
	print "Unique package names: "+str(len(reallist))
	print "Required packages:    "+str(len(alldeps))
	if "--pretend" in myopts:
		print "Number to remove:     "+str(len(cleanlist))
	else:
		print "Number removed:       "+str(len(cleanlist))

	post_emerge()
	
# "update", "system", or just process files:
else:
	if ("--pretend" in myopts) and not ("--fetchonly" in myopts):
		print
		print "These are the packages that I would merge, in order."
		print
	mydepgraph=depgraph(myaction,myopts)
	favorites=[]
	syslist=getlist("system")
	if myaction in ["system","world"]:
		print "Calculating",myaction,"dependencies  ",
		if not mydepgraph.xcreate(myaction):
			sys.exit(1)
		print "\b\b ...done!"
	else:
		if not myfiles:
			print "emerge: please tell me what to do."
			help()
			sys.exit(1)
			#we don't have any files to process; skip this step and exit
		print "Calculating dependencies  ",
		retval,favorites=mydepgraph.select_files(myfiles)
		if not retval:
			print "\n!!! Error calculating dependancies. Please correct."
			sys.exit(1)
		print "\b\b ...done!"
	if ("--pretend" in myopts) and not ("--fetchonly" in myopts):
		mydepgraph.display(mydepgraph.altlist())
	else:
		mydepgraph.merge(mydepgraph.altlist())
		if portage.settings["AUTOCLEAN"] and "yes"==portage.settings["AUTOCLEAN"]:
			print ">>> Auto-cleaning packages ..."
			unmerge("clean", ["world"])
	post_emerge()
