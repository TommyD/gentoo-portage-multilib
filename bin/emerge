#!/usr/bin/env spython
import os
import sys

if os.getuid()!=0:
	print "!!! emerge must be run by root."
	sys.exit(1)

import portage
import xpak
import string
import commands
import shutil

#build our package digraph

class depgraph:

	def __init__(self,mymode,myopts):
		self.mymode=mymode
		self.myopts=myopts
		virts=portage.getvirtuals("/")
		self.db={}
		self.db["/"]={"virtuals":virts,"vartree":portage.vartree("/",virts),"porttree":portage.portagetree("/",virts),"bintree":portage.binarytree("/",virts)}
		if portage.root!="/":
			pr=portage.root
			virts=portage.getvirtuals(pr)
			self.db[pr]={"virtuals":virts,"vartree":portage.vartree(pr,virts),"porttree":portage.portagetree(pr,virts),"bintree":portage.binarytree(pr,virts)}
		self.digraph=portage.digraph()

	def create(self,mybigkey=None,myparent=None):
		sys.stdout.write(".")	
		sys.stdout.flush()
		if self.digraph.hasnode(mybigkey):
			#if we've already hit this node before, we're already recursing on the dependencies.
			#no need to recurse again.
			if myparent:
				self.digraph.addnode(mybigkey,myparent)
			return 1
		mytype,myroot,mykey=string.split(mybigkey)
		if mytype=="binary":
			if not self.db[portage.root]["bintree"].exists_specific(mykey):
				print "\n\n!!!",mytype,mykey,"not found (possibly blocked by package.mask)\n"
				sys.exit(1)
			mytbz2=xpak.tbz2(self.db[portage.root]["bintree"].getname(mykey))
			edepend=["",string.join(mytbz2.getelements("RDEPEND")," ")]
		else:
			#ebuild specified
			if not self.db[myroot]["porttree"].exists_specific(mykey):
				print "\n\n!!!",mytype,mykey,"not found (possibly blocked by package.mask)\n"
				sys.exit(1)
				mydep={}
			myebuild=self.db[myroot]["porttree"].getname(mykey)
			edepend=portage.doebuild(myebuild,"depend",myroot,1,edebug)
			if edepend==1:
				print "!!! emerge aborting."
				sys.exit(1)
		mydep={}	
		#if portage.root=="/":
		#	mydep["/"]=edepend[0]+" "+edepend[1]
		#else:
		#	mydep["/"],mydep[portage.root]=edepend
		if myroot=="/":
			mydep["/"]=edepend[0]+" "+edepend[1]
		else:
			mydep["/"],mydep[myroot]=edepend
		self.digraph.addnode(mybigkey,myparent)
		for dep in mydep.keys():
			mycheck=self.db[dep]["vartree"].depcheck(mydep[dep])
			if mycheck[0]==0:
				print "!!! depgraph.create() error: string format:",mydep
				return 0
			for x in mycheck[1]:
				mynew=self.match(x,dep)
				if not self.digraph.hasnode(mynew):
					if not self.create(mynew,mybigkey):
						return 0
				else:
					self.digraph.addnode(mynew,mybigkey)
		return 1
	
	def altlist(self):
		mygraph=self.digraph.copy()
		dolist=["/"]
		retlist=[]
		for x in self.db.keys():
			self.db[x]["merge"]=[]
			if x not in dolist:
				dolist.append(x)
		while (not mygraph.empty()):
			mycurkey=mygraph.firstzero()
			if not mycurkey:
				print "!!! Error: circular dependencies"
				sys.exit(1)
			splitski=string.split(mycurkey)
			self.db[splitski[1]]["merge"].append(splitski)	
			mygraph.delnode(mycurkey)
		for x in dolist:
			for y in self.db[x]["merge"]:
				retlist.append(y)
		return retlist

	def syscreate(self,mylines):
		for x in mylines:
			myline=string.join(string.split(x))
			if not len(myline):
				continue
			if myline[0]=="#":
				continue
			if "update" not in self.mymode:
				mycheck=self.db[portage.root]["vartree"].depcheck(myline)
				if mycheck[0]==0:
					print "\n!!! Warning:",myline,"has an invalid depstring\n"
					continue
				if mycheck[1]==None:
					continue
				for x in mycheck[1]:
					self.create(self.match(myline))
			else:
				self.create(self.match(myline))
	
	def match(self,mydep,myroot=portage.root):
		myeb=self.db[portage.root]["porttree"].dep_bestmatch(mydep)
		if not myeb:
			print "\n!!! Error: couldn't find match for",mydep,"\n"
			sys.exit(1)
		if "--usepkg" in self.myopts:
			mypk=self.db[portage.root]["bintree"].dep_bestmatch(mydep)
			if myeb==mypk:
				myk="binary "+portage.root+" "+mypk
			else:
				myk="ebuild "+myroot+" "+myeb
		else:
			myk="ebuild "+myroot+" "+myeb
		return myk	
	
	def display(self,mylist):
		for x in mylist:
			if self.db[x[1]]["vartree"].exists_specific(x[2]):
				addl=" \x1b[33;01mR\x1b[0m "
			elif self.db[x[1]]["vartree"].exists_specific_cat(x[2]):
				addl="  \x1b[36;01mU\x1b[0m"
			else:
				addl="\x1b[32;01mN\x1b[0m  "
			print "["+x[0]+" "+addl+"]",x[2],"to",x[1]
				
	def merge(self,mylist):
		returnme=0
		#above line used by --fetchonly
		for x in mylist:
			myroot=x[1]
			print ">>> emerge",x[2],"to",x[1]
			#the last argument in the portage.doebuild() tells doebuild to *not* do dep checking
			#(emerge is already handling that)
			y=self.db[x[1]]["porttree"].getname(x[2])
			if x[0]=="ebuild":
				if "--fetchonly" in self.myopts:
					retval=portage.doebuild(y,"fetch",myroot,0,edebug)
					if retval:
						print
						print "!!! Fetch for",y,"failed, continuing..."
						print	
						returnme=1
				elif "--buildpkg" in self.myopts:
					#create pkg, then merge pkg
					retval=portage.doebuild(y,"clean",myroot,0,edebug)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					retval=portage.doebuild(y,"package",myroot,0,edebug)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					#dynamically update our database	
					self.db[portage.root]["bintree"].inject(x[2])
					mytbz2=self.db[portage.root]["bintree"].getname(x[2])
					retval=portage.pkgmerge(mytbz2,myroot)
					if retval==None:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
				else:
					retval=portage.doebuild(y,"clean",myroot,0,edebug)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					retval=portage.doebuild(y,"merge",myroot,0,edebug)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					#dynamically update our database	
			else:
				#merge the tbz2
				mytbz2=self.db[portage.root]["bintree"].getname(x[2])
				retval=portage.pkgmerge(mytbz2,x[1])
				if retval==None:
					print "!!! emerge aborting on ",y,"."
					sys.exit(1)
				#need to check for errors
			self.db[x[1]]["vartree"].inject(x[2])
			if "--autoclean" in self.myopts:
				retval=portage.doebuild(y,"clean",myroot,0,edebug)
				if retval:
					print "!!! emerge aborting on ",y,"."
					sys.exit(1)
		#my doing an exit this way, --fetchonly can continue to try to
		#fetch everything even if a particular download fails.
		if "--fetchonly" in self.myopts:
			if returnme:
				print "\n\n!!! Some fetch errors were encountered.  Please see above for details.\n\n"
				sys.exit(returnme)
			else:
				sys.exit(0)

def post_emerge(retval=0):
	global myopts
	print
	if "--pretend" in myopts:
		sys.exit(retval)
	root=portage.root
	if not os.path.isdir(root+"usr/share/info"):
		print "    "+root+"usr/share/info doesn't exist, skipping info regeneration."
	elif not os.path.exists("/usr/bin/install-info"):
		print "    /usr/bin/install-info doesn't exist; skipping info regeneration."
	else:
		print ">>> \x1b[32;01mRegenerating GNU info directory index...\x1b[0m"
		if os.path.exists(root+"usr/share/info/dir"):
			os.rename(root+"usr/share/info/dir",root+"usr/share/info/dir.old")
		icount=0
		for x in os.listdir(root+"usr/share/info"):
			if (x[-5:]==".info") or (x[-8:]==".info.gz"):
				myso=commands.getstatusoutput("/usr/bin/install-info --dir-file="+root+"usr/share/info/dir "+root+"usr/share/info/"+x)[1]
				if myso!="":
					print myso
				icount=icount+1
		print "    Processed",icount,"files."
	if portage.settings["CONFIG_PROTECT"]:
		print
		print ">>> \x1b[32;01mNote:\x1b[0m"
		print "    Config file protection is enabled."
		print "    \x1b[32;01mdirs:\x1b[0m "+portage.settings["CONFIG_PROTECT"]
		print "    \x1b[32;01mmasked-out dirs:\x1b[0m",portage.settings["CONFIG_PROTECT_MASK"]
		print "    /etc/env.d is hard-coded; type \"emerge --help config\" more information."
		print
	sys.exit(retval)

opts=["--help","--pretend","--buildpkg","--usepkg","--autoclean","--clean","--debug","--fetchonly"]
modes=["rsync","system","update","config"]
myopts=[]
mymode=[]
myfiles=[]
edebug=0
for x in sys.argv[1:]:
	if len(x)>=2:
		if x[0:2]=="--":
			if x in opts:
				myopts.append(x)
			else:
				print "!!! Error:",x,"is an invalid option."
				sys.exit(1)
		elif x in modes:
			if len(mymode)>=1:
				print "!!! Error: more than one mode specified on command-line."
				print "!!! Available modes:",modes
				sys.exit(1)
			else:
				mymode.append(x)
		elif os.path.exists(x):
			if not x in myfiles:
				myfiles.append(x)
		else:
			print "!!! Error:",x,"does not exist or is an invalid command-line option."
			sys.exit(1)
if not portage.settings.has_key("MAINTAINER"):
	if not "--autoclean" in myopts:
		myopts.append("--autoclean")
if "--debug" in myopts:
	edebug=1
if "--help" in myopts:
	if len(mymode)==0:
		print
		print "\x1b[01mYou can also type \"emerge --help system\" and \"emerge --help rsync\" for"
		print "additional help.\x1b[0m"
		print
		print "Usage: \x1b[36;01memerge\x1b[0m [ \x1b[32;01moptions\x1b[0m ] [ \x1b[36;01mebuildfile\x1b[0m | \x1b[36;01mtbz2file\x1b[0m ] ..."
		print "       \x1b[36;01memerge\x1b[0m [ \x1b[32;01moptions\x1b[0m ] \x1b[36;01msystem\x1b[0m"
		print "       \x1b[36;01memerge\x1b[0m [ \x1b[32;01m--clean\x1b[0m ] \x1b[36;01mrsync"
		print
		print "Options:"
		print "       \x1b[32;01m--help\x1b[0m [ mode ]"
		print "              display this help (specify optional \"rsync\" or \"system\" for"
		print "              more info)"
		print 
		print "       \x1b[32;01m--debug\x1b[0m"
		print "              tell emerge to run the \x1b[36;01mebuild\x1b[0m command in --debug"
		print "              mode.  In this mode, the bash build environment will run with"
		print "              the -x option, causing it to output verbose debug information"
		print "              to stdout.  --debug is great for finding bash syntax errors."
		print
		print "       \x1b[32;01m--fetchonly\x1b[0m"
		print "              Instead of doing any package building, just perform fetches for"
		print "              all packages (main package as well as all dependencies.)"
		print
		print "       \x1b[32;01m--usepkg\x1b[0m"
		print "              tell emerge to use binary packages (from $DISTDIR) if they are"
		print "              available, thus possibly avoiding some time-consuming compiles."
		print "              This option is useful for CD installs; you can export"
		print "              DISTDIR=/mnt/cdrom/packages and then use this option to have"
		print "              emerge \"pull\" binary packages from the CD in order to satisfy" 
		print "              dependencies."
		print
		print "       \x1b[32;01m--buildpkg\x1b[0m"
		print "              tell emerge to build binary packages for all ebuilds processed"
		print "              (in addition to actually merging the packages.  Useful for"
		print "              maintainers or if you administrate multiple Gentoo Linux"
		print "              systems (build once, emerge tbz2s everywhere)."
		print
		print "       \x1b[32;01m--autoclean\x1b[0m"
		print "              emerge normally cleans out the package-specific temporary"
		print "              build directory before it starts the building a package.  With"
		print "              --autoclean, it will also clean the directory *after* the"
		print "              build completes.  This option is automatically enabled for"
		print "              normal users, but maintainers can use this option to enable"
		print "              autocleaning."
		print
		print "       \x1b[32;01m--pretend\x1b[0m"
		print "              instead of actually performing the merge, simply display what"
		print "              ebuilds and tbz2s *would* have been installed if --pretend"
		print "              weren't used.  Using --pretend is strongly recommended before"
		print "              installing an unfamiliar package.  In the printout, N = new,"
		print "              U = upgrading, R = replacing"
		print
	elif "rsync" in mymode:
		print
		print "       \x1b[36;01memerge rsync"
		print "       emerge \x1b[32;01m--clean\x1b[36;01m rsync\x1b[0m"
		print
		print "       \"emerge rsync\" initiates an rsync update with cvs.gentoo.org,"
		print "       updating your Portage tree (typically in /usr/portage).  This option"
		print "       will erase any changes that you have made to existing Portage files"
		print "       so be careful.  \"emerge --clean rsync\" does the same thing as \"emerge"
		print "       rsync\", but files that no longer exist on our server are removed."
		print
	elif "system" in mymode:
		print
		print "       \x1b[36;01memerge\x1b[0m [ \x1b[32;01moptions\x1b[0m ] \x1b[36;01msystem\x1b[0m"
		print
		print "       \"emerge system\" is the Portage system update command.  When run, it"
		print "       will scan the /etc/make.profile/packages file and determine what"
		print "       packages need to be installed so that your system meets the minimum"
		print "       requirements of your current system profile.  Note that this doesn't"
		print "       necessarily bring your system up-to-date at all; instead, it just"
		print "       ensures that you have no missing parts.  For example, if your system"
		print "       profile specifies that you should have sys-apps/iptables installed"
		print "       and you don't, then \"emerge system\" will install it (the most"
		print "       recent version that matches the profile spec) for you.  It's always a"
		print "       good idea to do an \"emerge --pretend system\" before an \"emerge"
		print "       system\", just so you know what emerge is planning to do."
		print
	elif "config" in mymode:
		outstuff="""
\x1b[32;01mConfig file management support (preliminary)\x1b[0m

By default, Portage will \x1b[32;01mnot\x1b[0m overwrite any files inside the directories listed
in the CONFIG_PROTECT variable in /etc/make.globals (which is set to /etc and
/var/qmail/control, typically.)  Instead, if Portage is asked to overwrite a
file in one of these directories (or a subdirectory inside one of these
directories), it will install the file with an alternate filename, using a
._cfgXXXX_ prefix (where XXXX is a four-digit number, starting with 0000) so
that the original config file is preserved.

The purpose of this feature is to give the administrator the option to review
any potential changes to files in these directories before they are applied.
Soon, we will have a special \"emerge config\" system that will step the
administrator through an interactive process, allowing him/her to review the
changes and selectively merge these changes into the  production config files.
But right now, \"emerge config\" doesn't exist, so users will need to scan /etc
and protected dirs for any ._cfgXXXX_ files, and then manually review them and
apply any desired changes to their production files:

# find /etc -iname ._cfg????_*

You can disable this feature by setting CONFIG_PROTECT="" in /etc/make.conf.
Then, Portage will mercilessly auto-update your config files.  Alternatively,
you can leave Config File Protection on but tell Portage that it can overwrite
files in certain specific /etc subdirectories.  For example, if you wanted
Portage to automatically update your rc scripts and your wget configuration,
but didn't want any other changes made without your explicit approval, you'd
add this to /etc/make.conf:

CONFIG_PROTECT_MASK="/etc/wget /etc/rc.d"

"""
		print outstuff
	sys.exit(1)
		
if "--pretend" in myopts:
		print
		print "These are the packages that I would merge, in order."
		print

if "rsync" in mymode:
	if not os.path.exists("/usr/bin/rsync"):
		print "!!! /usr/bin/rsync does not exist, so rsync support is disabled."
		sys.exit(1)
	rclean=0
	myportdir=portage.settings["PORTDIR"]
	if myportdir[-1]=="/":
		myportdir=myportdir[:-1]
	if not os.path.exists(myportdir):
		print ">>>",myportdir,"not found, creating it."
		os.makedirs(myportdir,0755)	
	if "--clean" in myopts:
			#we'll --delete files when we rsync
			rclean=1
	mycommand="/usr/bin/rsync -rlptDv --stats --progress "
	if rclean:
		mycommand=mycommand+"--delete --exclude='distfiles/*' --exclude='packages/*' "
	mycommand=mycommand+"rsync://cvs.gentoo.org/gentoo-x86-portage/* "+myportdir
	print ">>> starting rsync with cvs.gentoo.org..."
	#protect users that did not set a default umask
	os.umask(022)
	sys.exit(os.system(mycommand))	

if ("system" in mymode) or ("update" in mymode):
	#system profile mode
	if os.path.exists(portage.root+"etc/make.profile/packages"):
		pfile=portage.root+"etc/make.profile/packages"
	elif os.path.exists("/etc/make.profile/packages"):
		print ">>> Couldn't find",portage.root+"/etc/make.profile/packages;"
		print ">>> Using /etc/make.profile/packages instead."
		pfile="/etc/make.profile/packages"
	elif os.path.exists(os.path.normpath(portage.settings["PORTDIR"]+"/profiles/default/packages")):
		print ">>> Couldn't find",portage.root+"/etc/make.profile/packages;"
		print ">>> Couldn't find /etc/make.profile/packages;"
		print ">>> Found default profile in /usr/portage/profiles; using it instead."
		pfile=os.path.normpath(portage.settings["PORTDIR"]+"/profiles/default/packages")
	else:
		print "!!! Couldn't find",portage.root+"/etc/make.profile/packages;"
		print "!!! Couldn't find /etc/make.profile/packages;"
		print "!!! Couldn't find /usr/portage/profiles/default/packages;"
		print "\"system\" mode unavailable."
		sys.exit(1)
	myfile=open(pfile,"r")
	mylines=myfile.readlines()
	myfile.close()
	mydepgraph=depgraph(mymode,myopts)
	print "Calculating system dependencies",
	mydepgraph.syscreate(mylines)
	print " done!"
	if "--pretend" in myopts:
		mydepgraph.display(mydepgraph.altlist())
	else:
		mydepgraph.merge(mydepgraph.altlist())
	post_emerge()
mydepgraph=depgraph(mymode,myopts)
for mypkg in myfiles:
	if mypkg[-5:]==".tbz2":
		mytype="binary"
		mytbz2=xpak.tbz2(mypkg)
		mykey=mytbz2.getelements("CATEGORY")[0]+"/"+os.path.basename(mypkg)[:-5]
	elif mypkg[-7:]==".ebuild":
		mytype="ebuild"
		mykey=os.path.basename(os.path.abspath(mypkg+"/../.."))+"/"+os.path.basename(mypkg)[:-7]
	else:
		print "!!! Error:",x,"is neither an ebuild nor a .tbz2 package."
		sys.exit(1)
	print "Calculating dependencies",
	mydepgraph.create(mytype+" "+portage.root+" "+mykey)
	print " done!"
	if "--pretend" in myopts:
		mydepgraph.display(mydepgraph.altlist())
	else:
		mydepgraph.merge(mydepgraph.altlist())
	post_emerge()
